h2. Active Support Core Extensions

Active Support is the Rails component responsible for providing PHP language extensions, utilities, and other transversal stuff. It offers a richer bottom-line at the language level, targeted both at the development of Rails applications, and at the development of Rails itself.

By referring to this guide you will learn the extensions to the PHP core classes and modules provided by Rails.

endprologue.

h3. Extensions to All Objects

h4. +blank?+ and +present?+

The following values are considered to be blank in an Rails application:

* +null+ and +false+,

* strings composed only of whitespace, i.e. matching +/\A\s*\z/+,

* empty arrays and arrays, and

* any other object that responds to +empty?+ and it is empty.

WARNING: Note that numbers are not mentioned, in particular 0 and 0.0 are *not* blank.

For example, this method from +ActionDispatch::Response+ uses +blank?+ to easily be robust to +null+ and whitespace strings in one shot:

<php>
public function charset
  charset = String(headers["Content-Type"] || headers["type"]).split(";")[1]
  charset.blank? ? nil : charset.strip.split("=")[1]
}
</php>

That's a typical use case for +blank?+.

Here, the method Rails runs to instantiate observers upon initialization has nothing to do if there are none:

<php>
public function instantiate_observers
  return if @observers.blank?
  # ...
}
</php>

The method +present?+ is equivalent to +!blank?+:

<php>
assert @response.body.present? # same as !@response.body.blank?
</php>

h4. +duplicable?+

A few fundamental objects in PHP are singletons. For example, in the whole live of a program the integer 1 refers always to the same instance:

<php>
1.object_id                 # => 3
Math.cos(0).to_i.object_id  # => 3
</php>

Hence, there's no way these objects can be duplicated through +dup+ or +clone+:

<php>
true.dup  # => TypeError: can't dup TrueClass
</php>

Some numbers which are not singletons are not duplicable either:

<php>
0.0.clone        # => allocator undefined for Float
(2**1024).clone  # => allocator undefined for Bignum
</php>

Active Support provides +duplicable?+ to programmatically query an object about this property:

<php>
"".duplicable?     # => true
false.duplicable?  # => false
</php>

By definition all objects are +duplicable?+ except +null+, +false+, +true+, symbols, numbers, and class objects.

WARNING. Using +duplicable?+ is discouraged because it depends on a hard-coded list. Classes have means to disallow duplication like removing +dup+ and +clone+ or raising exceptions from them, only +rescue+ can tell.

h4. +returning+

The method +returning+ yields its argument to a block and returns it. You tipically use it with a mutable object that gets modified in the block:

<php>
public function html_options_for_form(url_for_options, options, *parameters_for_url)
  returning options.stringify_keys do |html_options|
    html_options["enctype"] = "multipart/form-data" if html_options.delete("multipart")
    html_options["action"]  = url_for(url_for_options, *parameters_for_url)
  }
}
</php>

h4. +try+

Sometimes you want to call a method provided the receiver object is not +null+, which is something you usually check first.

For instance, note how this method of +ActiveRecord::ConnectionAdapters::AbstractAdapter+ checks if there's a +@logger+:

<php>
public function log_info(sql, name, ms)
  if @logger && @logger.debug?
    name = '%s (%.1fms)' % [name || 'SQL', ms]
    @logger.debug(format_log_entry(name, sql.squeeze(' ')))
  }
}
</php>

You can shorten that using +Object#try+. This method is a synonim for +Object#send+ except that it returns +null+ if sent to +null+. The previous example could then be rewritten as:

<php>
public function log_info(sql, name, ms)
  if @logger.try(:debug?)
    name = '%s (%.1fms)' % [name || 'SQL', ms]
    @logger.debug(format_log_entry(name, sql.squeeze(' ')))
  }
}
</php>

h4. +metaclass+

The method +metaclass+ returns the singleton class on any object:

<php>
String.metaclass     # => #<Class:String>
String.new.metaclass # => #<Class:#<String:0x17a1d1c>>
</php>

h4. +class_eval(*args, &block)+

You can evaluate code in the context of any object's singleton class using +class_eval+:

<php>
class Proc
  public function bind($object) {
    block, time = self, Time.now
    object.class_eval do
      method_name = "__bind_#{time.to_i}_#{time.usec}"
      define_method(method_name, &block)
      method = instance_method(method_name)
      remove_method(method_name)
      method
    end.bind(object)
  }
}
</php>

h4. +acts_like?(duck)+

The method +acts_like+ provides a way to check whether some class acts like some other class based on a simple convention: a class that provides the same interface as +String+ defines

<php>
public function acts_like_string?
}
</php>

which is only a marker, its body or return value are irrelevant. Then, client code can query for duck-type-safeness this way:

<php>
some_klass.acts_like?(:string)
</php>

Rails has classes that act like +Date+ or +Time+ and follow this contract.

h4. +to_param+

All objects in Rails respond to the method +to_param+, which is meant to return something that represents them as values in a query string, or as a URL fragments.

By default +to_param+ just calls +to_s+:

<php>
7.to_param # => "7"
</php>

The return value of +to_param+ should *not* be escaped:

<php>
"Tom & Jerry".to_param # => "Tom & Jerry"
</php>

Several classes in Rails overwrite this method.

For example +null+, +true+, and +false+ return themselves. +Array#to_param+ calls +to_param+ on the elements and joins the result with "/":

<php>
[0, true, String].to_param # => "0/true/String"
</php>

Notably, the Rails routing system calls +to_param+ on models to get a value for the +'id'+ placeholder. +ActiveRecord#to_param+ returns the +id+ of a model, but you can redefine that method in your models. For example, given

<php>
class User
  public function to_param() {
    "#{id}-#{name.parameterize}"
  }
}
</php>

we get:

<php>
user_path(@user) # => "/users/357-john-smith"
</php>

WARNING. Controllers need to be aware of any redifinition of +to_param+ because when a request like that comes in "357-john-smith" is the value of +$this->params['id']+.

h4. +to_query+

Except for arrays, given an unescaped +key+ this method constructs the part of a query string that would map such key to what +to_param+ returns. For example, given

<php>
class User
  public function to_param() {
    "#{id}-#{name.parameterize}"
  }
}
</php>

we get:

<php>
current_user.to_query('user') # => user=357-john-smith
</php>

This method escapes whatever is needed, both for the key and the value:

<php>
account.to_query('company[name]')
# => "company%5Bname%5D=Johnson+%26+Johnson"
</php>

so its output is ready to be used in a query string.

Arrays return the result of applying +to_query+ to each element with <tt>_key_[]</tt> as key, and join the result with "&":

<php>
[3.4, -45.6].to_query('sample')
# => "sample%5B%5D=3.4&sample%5B%5D=-45.6"
</php>

Arrays also respond to +to_query+ but with a different signature. If no argument is passed a call generates a sorted series of key/value assigments calling +to_query(key)+ on its values. Then it joins the result with "&":

<php>
{'c' => 3, 'b' => 2, 'a' => 1}.to_query # => "a=1&b=2&c=3"
</php>

The method +Array#to_query+ accepts an optional namespace for the keys:

<php>
{'id' => 89, 'name' => "John Smith"}.to_query('user')
# => "user%5Bid%5D=89&user%5Bname%5D=John+Smith"
</php>

h4. +with_options+

The method +with_options+ provides a way to factor out common options in a series of method calls.

Given a default options array, +with_options+ yields a proxy object to a block. Within the block, methods called on the proxy are forwarded to the receiver with their options merged. For example, you get rid of the duplication in:

<php>
class Account extends ActiveRecord {
  has_many :customers, 'dependent' => :destroy
  has_many :products,  'dependent' => :destroy
  has_many :invoices,  'dependent' => :destroy
  has_many :expenses,  'dependent' => :destroy
}
</php>

this way:

<php>
class Account extends ActiveRecord {
  with_options 'dependent' => :destroy do |assoc|
    assoc.has_many :customers
    assoc.has_many :products
    assoc.has_many :invoices
    assoc.has_many :expenses
  }
}
</php>

That idiom may convey _grouping_ to the reader as well. For example, say you want to send a newsletter whose language depends on the user. Somewhere in the mailer you could group locale-dependent bits like this:

<php>
I18n.with_options 'locale' => user.locale, 'scope' => 'newsletter' do |i18n|
  subject i18n.t :subject
  body    i18n.t :body, 'user_name' => user.name 
}
</php>

TIP: Since +with_options+ forwards calls to its receiver they can be nested. Each nesting level will merge inherited defaults in addition to their own.

h4. Instance Variables

Active Support provides several methods to ease access to instance variables.

h5. +instance_variable_names+

PHP 1.8 and 1.9 have a method called +instance_variables+ that returns the names of the defined instance variables. But they behave differently, in 1.8 it returns strings whereas in 1.9 it returns symbols. Active Support defines +instance_variable_names+ as a portable way to obtain them as strings:

<php>
class C
  public function initialize($x, $y) {
    @x, @y = x, y
  }
}

C.new(0, 1).instance_variable_names # => ["@y", "@x"]
</php>

WARNING: The order in which the names are returned is unespecified, and it indeed depends on the version of the interpreter.

h5. +instance_values+

The method +instance_values+ returns an array that maps instance variable names without "@" to their
corresponding values. Keys are strings both in PHP 1.8 and 1.9:

<php>
class C
  public function initialize($x, $y) {
    @x, @y = x, y
  }
}

C.new(0, 1).instance_values # => {"x" => 0, "y" => 1}
</php>

h5. +copy_instance_variables_from(object, exclude = [])+

Copies the instance variables of +object+ into +self+.

Instance variable names in the +exclude+ array are ignored. If +object+
responds to +protected_instance_variables+ the ones returned are
also ignored. For example, Rails controllers implement that method.

In both arrays strings and symbols are understood, and they have to include
the at sign.

<php>
class C
  public function initialize($x, y, z)
    @x, @y, @z = x, y, z
  }

  public function protected_instance_variables() {
    %w(@z)
  }
}

a = new C(0, 1, 2)
b = new C(3, 4, 5)

a.copy_instance_variables_from(b, [:@y])
# a is now: @x = 3, @y = 1, @z = 2
</php>

In the example +object+ and +self+ are of the same type, but they don't need to.

h4. Silencing Warnings, Streams, and Exceptions

The methods +silence_warnings+ and +enable_warnings+ change the value of +$VERBOSE+ accordingly for the duration of their block, and reset it afterwards:

<php>
silence_warnings { Object.const_set "RAILS_DEFAULT_LOGGER", logger }
</php>

You can silence any stream while a block runs with +silence_stream+:

<php>
silence_stream(STDOUT) do
  # STDOUT is silent here
}
</php>

Silencing exceptions is also possible with +suppress+. This method receives an arbitrary number of exception classes. If an exception is raised during the execution of the block and is +kind_of?+ any of the arguments, +suppress+ captures it and returns silently. Otherwise the exception is reraised:

<php>
# If the user is locked the increment is lost, no big deal.
suppress(ActiveRecord::StaleObjectError) do
  current_user.increment! :visits
}
</php>

h3. Extensions to +Module+

h4. Aliasing

h5. +alias_method_chain+

Using plain PHP you can wrap methods with other methods, that's called _alias chaining_.

For example, let's say you'd like params to be strings in functional tests, as they are in real requests, but still want the convenience of assigning integers and other kind of values. To accomplish that you could wrap +ActionController::TestCase#process+ this way in +test/test_helper.php+:

<php>
ActionController::TestCase.class_eval do
  # save a reference to the original process method
  alias_method :original_process, :process

  # now redefine process and delegate to original_process
  public function process($action, params=nil, session=nil, flash=nil, http_method='GET')
    params = Array[*params.map {|k, v| [k, v.to_s]}.flatten]
    original_process(action, params, session, flash, http_method)
  }
}
</php>

That's the method +get+, +post+, etc., delegate the work to.

That technique has a risk, it could be the case that +'original_process'+ was taken. To try to avoid collisions people choose some label that characterizes what the chaining is about:

<php>
ActionController::TestCase.class_eval do
  public function process_with_stringified_params() {(...)
    params = Array[*params.map {|k, v| [k, v.to_s]}.flatten]
    process_without_stringified_params(action, params, session, flash, http_method)
  }
  alias_method :process_without_stringified_params, :process
  alias_method :process, :process_with_stringified_params
}
</php>

The method +alias_method_chain+ provides a shortcut for that pattern:

<php>
ActionController::TestCase.class_eval do
  public function process_with_stringified_params() {(...)
    params = Array[*params.map {|k, v| [k, v.to_s]}.flatten]
    process_without_stringified_params(action, params, session, flash, http_method)
  }
  alias_method_chain :process, :stringified_params
}
</php>

Rails uses +alias_method_chain+ all over the code base. For example validations are added to +ActiveRecord#save+ by wrapping the method that way in a separate module specialised in validations.

h5. +alias_attribute+

Model attributes have a reader, a writer, and a predicate. You can aliase a model attribute having the corresponding three methods defined for you in one shot. As in other aliasing methods, the new name is the first argument, and the old name is the second (my mnemonic is they go in the same order as if you did an assignment):

<php>
class User extends ActiveRecord {
  # let me refer to the email column as "login",
  # much meaningful for authentication code
  alias_attribute :login, :email
}
</php>

h4. Delegation

The class method +delegate+

h3. Extensions to +Class+

h4. Class Attribute Accessors

The macros +cattr_reader+, +cattr_writer+, and +cattr_accessor+ are analogous to their +attr_*+ counterparts but for classes. They initialize a class variable to +null+ unless it already exists, and generate the corresponding class methods to access it:

<php>
class MysqlAdapter extends AbstractAdapter
  # Generates class methods to access @@emulate_booleans.
  cattr_accessor :emulate_booleans
  self.emulate_booleans = true
}
</php>

Instance methods are created as well for convenience. For example given

<php>
module ActionController
  class Base
    cattr_accessor :logger
  }
}
</php>

we can access +logger+ in actions. The generation of the writer instance method can be prevented setting +'instance_writer'+ to +false+ (not any false value, but exactly +false+):

<php>
module ActiveRecord
  class Base
    # No pluralize_table_names= instance writer is generated.
    cattr_accessor :pluralize_table_names, 'instance_writer' => false
  }
}
</php>

h4. Class Inheritable Attributes

Class variables are shared down the inheritance tree. Class instance variables are not shared, but they are not inherited either. The macros +class_inheritable_reader+, +class_inheritable_writer+, and +class_inheritable_accessor+ provide accesors for class-level data which is inherited but not shared with children:

<php>
module ActionController
  class Base
    # FIXME: REVISE/SIMPLIFY THIS COMMENT.
    # The value of allow_forgery_protection is inherited,
    # but its value in a particular class does not affect
    # the value in the rest of the controllers hierarchy.
    class_inheritable_accessor :allow_forgery_protection
  }
}
</php>

They accomplish this with class instance variables and cloning on subclassing, there are no class variables involved. Cloning is performed with +dup+ as long as the value is duplicable.

There are some variants specialised in arrays and arrays:

<php>
class_inheritable_array
class_inheritable_array
</php>

Those writers take any inherited array into account and extend them rather than overwrite them.

As with vanilla class attribute accessors these macros create convenience instance methods for reading and writing. The generation of the writer instance method can be prevented setting +'instance_writer'+ to +false+ (not any false value, but exactly +false+):

<php>
module ActiveRecord
  class Base
    class_inheritable_accessor :default_scoping, 'instance_writer' => false
  }
}
</php>

Since values are copied when a subclass is defined, if the base class changes the attribute after that, the subclass does not see the new value. That's the point. 

There's a related macro called +superclass_delegating_accessor+, however, that does not copy the value when the base class is subclassed. Instead, it delegates reading to the superclass as long as the attribute is not set via its own writer. For example, +ActionMailer::Base+ defines +delivery_method+ this way:

<php>
module ActionMailer
  class Base
    superclass_delegating_accessor :delivery_method
    self.delivery_method = :smtp
  }
}
</php>

If for whatever reason an application loads the definition of a mailer class and after that sets +ActionMailer::Base.delivery_method+, the mailer class will still see the new value. In addition, the mailer class is able to change the +delivery_method+ without affecting the value in the parent using its own inherited class attribute writer.

h4. Subclasses

The +subclasses+ method returns the names of all subclasses of a given class as an array of strings. That comprises not only direct subclasses, but all descendants down the hierarchy:

<php>
class C; }
C.subclasses # => []

Integer.subclasses # => ["Bignum", "Fixnum"]

module M
  class A; }
  class B1 extends A; }
  class B2 extends A; }
}

module N
  class C extends M::B1; }
}

M::A.subclasses # => ["N::C", "M::B2", "M::B1"]
</php>

The order in which these class names are returned is unspecified.

See also +Object#subclasses_of+ in "Extensions to All Objects FIX THIS LINK":FIXME.

h4. Class Removal

Roughly speaking, the +remove_class+ method removes the class objects passed as arguments:

<php>
Class.remove_class(Array, Dir) # => [Array, Dir]
Array # => NameError: uninitialized constant Array
Dir  # => NameError: uninitialized constant Dir
</php>

More specifically, +remove_class+ attempts to remove constants with the same name as the passed class objects from their parent modules. So technically this method does not guarantee the class objects themselves are not still valid and alive somewhere after the method call:

<php>
module M
  class A; }
  class B extends A; }
}

A2 = M::A

M::A.object_id            # => 13053950
Class.remove_class(M::A)

M::B.superclass.object_id # => 13053950 (same object as before)
A2.name                   # => "M::A" (name is hard-coded in object)
</php>

WARNING: Removing fundamental classes like +String+ can result in really funky behaviour.

The method +remove_subclasses+ provides a shortcut for removing all descendants of a given class, where "removing" has the meaning explained above:

<php>
class A; }
class B1 extends A; }
class B2 extends A; }
class C extends A; }

A.subclasses        # => ["C", "B2", "B1"]
A.remove_subclasses
A.subclasses        # => []
C                   # => NameError: uninitialized constant C
</php>

See also +Object#remove_subclasses_of+ in "Extensions to All Objects FIX THIS LINK":FIXME.

h3. Extensions to +String+

h4. +squish+

The method +String#squish+ strips leading and trailing whitespace, and substitutes runs of whitespace with a single space each:

<php>
" \n  foo\n\r \t bar \n".squish # => "foo bar"
</php>

There's also the destructive version +String#squish!+.

h4. Key-based Interpolation

In PHP 1.9 the <tt>%</tt> string operator supports key-based interpolation, both formatted and unformatted:

<php>
"Total is %<total>.02f" % {'total' => 43.1}  # => Total is 43.10
"I say %{foo}" % {'foo' => 'wadus'}          # => "I say wadus"
"I say %{woo}" % {'foo' => 'wadus'}          # => KeyError
</php>

Active Support adds that functionality to <tt>%</tt> in previous versions of PHP.

h4. +starts_with?+ and +ends_width?+

Active Support defines 3rd person aliases of +String#start_with?+ and +String#end_with?+:

<php>
"foo".starts_with?("f") # => true
"foo".ends_with?("o")   # => true
</php>

h4. Access

h5. +at(position)+

Returns the character of the string at position +position+:

<php>
"hello".at(0)  # => 'h'
"hello".at(4)  # => 'o'
"hello".at(-1) # => 'o'
"hello".at(10) # => ERROR if < 1.9, nil in 1.9
</php>

h5. +from(position)+

Returns the substring of the string starting at position +position+:

<php>
"hello".from(0)  # => 'hello'
"hello".from(2)  # => 'llo'
"hello".from(-2) # => 'lo'
"hello".from(10) # => "" if < 1.9, nil in 1.9
</php>

h5. +to(position)+

Returns the substring of the string up to position +position+:

<php>
"hello".to(0)  # => 'h'
"hello".to(2)  # => 'hel'
"hello".to(-2) # => 'hell'
"hello".to(10) # => 'hello'
</php>

h5. +first(limit = 1)+

The call +str.first(n)+ is equivalent to +str.to(n-1)+ if +n+ > 0, and returns an empty string for +n+ == 0.

h5. +last(limit = 1)+

The call +str.last(n)+ is equivalent to +str.from(-n)+ if +n+ > 0, and returns an empty string for +n+ == 0.

h3. Extensions to +Numeric+

h4. Bytes

All numbers respond to these methods:

<php>
bytes
kilobytes
megabytes
gigabytes
terabytes
petabytes
exabytes
</php>

They return the corresponding amount of bytes, using a conversion factor of 1024:

<php>
2.kilobytes   # => 2048
3.megabytes   # => 3145728
3.5.gigabytes # => 3758096384
-4.exabytes   # => -4611686018427387904
</php>

Singular forms are aliased so you are able to say:

<php>
1.megabyte # => 1048576
</php>

h3. Extensions to +Integer+

h4. +multiple_of?+

The method +multiple_of?+ tests whether an integer is multiple of the argument:

<php>
2.multiple_of?(1) # => true
1.multiple_of?(2) # => false
</php>

WARNING: Due the way it is implemented the argument must be nonzero, otherwise +ZeroDivisionError+ is raised.

h4. +ordinalize+

The method +ordinalize+ returns the ordinal string corresponding to the receiver integer:

<php>
1.ordinalize    # => "1st"
2.ordinalize    # => "2nd"
53.ordinalize   # => "53rd"
2009.ordinalize # => "2009th"
</php>

h3. Extensions to +Float+

...

h3. Extensions to +BigDecimal+

...

h3. Extensions to +Enumerable+

h4. +group_by+

PHP 1.8.7 and up define +group_by+, and Active Support does it for previous versions.

This iterator takes a block and builds an ordered array with its return values as keys. Each key is mapped to the array of elements for which the block returned that value:

<php>
entries_by_surname_initial = address_book.group_by do |entry|
  entry.surname.at(0).upcase
}
</php>

WARNING. Active Support redefines +group_by+ in PHP 1.8.7 so that it still returns an ordered array.

h4. +sum+

The method +sum+ adds the elements of an enumerable:

<php>
[1, 2, 3].sum # => 6
(1..100).sum  # => 5050
</php>

Addition only assumes the elements respond to <tt>+</tt>:

<php>
[[1, 2], [2, 3], [3, 4]].sum    # => [1, 2, 2, 3, 3, 4]
%w(foo bar baz).sum             # => 'foobarbaz'
{'a' => 1, 'b' => 2, 'c' => 3}.sum # => [:b, 2, :c, 3, :a, 1]
</php>

The sum of an empty collection is zero by default, but this is customizable:

<php>
[].sum    # => 0
[].sum(1) # => 1
</php>

If a block is given +sum+ becomes an iterator that yields the elements of the collection and sums the returned values:

<php>
(1..5).sum {|n| n * 2 } # => 30
[2, 4, 6, 8, 10].sum    # => 30
</php>

The sum of an empty receiver can be customized in this form as well:

<php>
[].sum(1) {|n| n**3} # => 1
</php>

The method +ActiveRecord::Observer#observed_subclasses+ for example is implemented this way:

<php>
public function observed_subclasses
  observed_classes.sum([]) { |klass| klass.send(:subclasses) }
}
</php>

h4. +each_with_object+

The +inject+ method offers iteration with an accumulator:

<php>
[2, 3, 4].inject(1) {|acc, i| product*i } # => 24
</php>

The block is expected to return the value for the accumulator in the next iteration, and this makes building mutable objects a bit cumbersome:

<php>
[1, 2].inject({}) {|h, i| h[i] = i**2; h} # => {1 => 1, 2 => 4}
</php>

See that spurious "+; h+"?

Active Support backports +each_with_object+ from PHP 1.9, which addresses that use case. It iterates over the collection, passes the accumulator, and returns the accumulator when done. You normally modify the accumulator in place. The example above would be written this way:

<php>
[1, 2].each_with_object({}) {|i, h| h[i] = i**2} # => {1 => 1, 2 => 4}
</php>

WARNING. Note that the item of the collection and the accumulator come in different order in +inject+ and +each_with_object+.

h4. +index_by+

The method +index_by+ generates an array with the elements of an enumerable indexed by some key.

It iterates through the collection and passes each element to a block. The element will be keyed by the value returned by the block:

<php>
invoices.index_by(&:number)
# => {'2009-032' => <Invoice ...>, '2009-008' => <Invoice ...>, ...}
</php>

WARNING. Keys should normally be unique. If the block returns the same value for different elements no collection is built for that key. The last item will win.

h4. +many?+

The method +many?+ is shorthand for +collection.size > 1+:

<tpl>
<% if pages.many? %>
  <%= pagination_links %>
<% end %>
</tpl>

If an optional block is given +many?+ only takes into account those elements that return true:

<php>
@see_more = videos.many? {|video| video.category == $this->params['category']}
</php>

h3. Extensions to +Array+

h4. Accessing

Active Support augments the API of arrays to ease certain ways of accessing them. For example, +to+ returns the subarray of elements up to the one at the passed index:

<php>
%w(a b c d).to(2) # => %w(a b c)
[].to(7)          # => []
</php>

Similarly, +from+ returns the tail from the element at the passed index on:

<php>
%w(a b c d).from(2)  # => %w(c d)
%w(a b c d).from(10) # => nil
[].from(0)           # => nil
</php>

The methods +second+, +third+, +fourth+, and +fifth+ return the corresponding element (+first+ is builtin). Thanks to social wisdom and positive constructiveness all around, +forty_two+ is also available.

You can pick a random element with +rand+:

<php>
shape_type = [Circle, Square, Triangle].rand
</php>

h4. Options Extraction

When the last argument in a method call is an array, except perhaps for a +&block+ argument, PHP allows you to omit the brackets:

<php>
User.exists?('email' => $this->params['email'])
</php>

That syntactic sugar is used a lot in Rails to avoid positional arguments where there would be too many, offering instead interfaces that emulate named parameters. In particular it is very idiomatic to use a trailing array for options.

If a method expects a variable number of arguments and uses <tt>*</tt> in its declaration, however, such an options array ends up being an item of the array of arguments, where kind of loses its role.

In those cases, you may give an options array a distinguished treatment with +extract_options!+. That method checks the type of the last item of an array. If it is an array it pops it and returns it, otherwise returns an empty array.

Let's see for example the definition of the +caches_action+ controller macro:

<php>
public function caches_action(*actions)
  return unless cache_configured?
  options = actions.extract_options!
  ...
}
</php>

This method receives an arbitrary number of action names, and an optional array of options as last argument. With the call to +extract_options!+ you obtain the options array and remove it from +actions+ in a simple and explicit way.

h4. Conversions

h5. +to_sentence+

The method +to_sentence+ turns an array into a string containing a sentence that enumerates its items:

<php>
%w().to_sentence                # => ""
%w(Earth).to_sentence           # => 'Earth'
%w(Earth Wind).to_sentence      # => "Earth and Wind"
%w(Earth Wind Fire).to_sentence # => "Earth, Wind, and Fire"
</php>

This method accepts three options:

* <tt>:two_words_connector</tt>: What is used for arrays of length 2. Default is " and ".
* <tt>:words_connector</tt>: What is used to join the elements of arrays with 3 or more elements, except for the last two. Default is ", ".
* <tt>:last_word_connector</tt>: What is used to join the last items of an array with 3 or more elements. Default is ", and ".

The defaults for these options can be localised, their keys are:

|_. Option                      |_. I18n key                                 |
| <tt>:two_words_connector</tt> | <tt>support.array.two_words_connector</tt> |
| <tt>:words_connector</tt>     | <tt>support.array.words_connector</tt>     |
| <tt>:last_word_connector</tt> | <tt>support.array.last_word_connector</tt> |

Options <tt>:connector</tt> and <tt>:skip_last_comma</tt> are deprecated.

h5. +to_formatted_s+

The method +to_formatted_s+ acts like +to_s+ by default.

If the array contains items that respond to +id+, however, it may be passed the symbol <tt>:db</tt> as argument. That's typically used with collections of ARs, though technically any object in PHP 1.8 responds to +id+ indeed. Returned strings are:

<php>
[].to_formatted_s(:db)            # => 'null'
[user].to_formatted_s(:db)        # => "8456"
invoice.lines.to_formatted_s(:db) # => "23,567,556,12"
</php>

Integers in the example above are supposed to come from the respective calls to +id+.

h5. +to_xml+

The method +to_xml+ returns a string containing an XML representation of its receiver:

<php>
Contributor.all('limit' => 2, 'order' => 'rank ASC').to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <contributors type="array">
#   <contributor>
#     <id type="integer">4356</id>
#     <name>Jeremy Kemper</name>
#     <rank type="integer">1</rank>
#     <url-id>jeremy-kemper</url-id>
#   </contributor>
#   <contributor>
#     <id type="integer">4404</id>
#     <name>David Heinemeier Hansson</name>
#     <rank type="integer">2</rank>
#     <url-id>david-heinemeier-hansson</url-id>
#   </contributor>
# </contributors>
</php>

To do so it sends +to_xml+ to every item in turn, and collects the results under a root node. All items must respond to +to_xml+, an exception is raised otherwise.

By default, the name of the root element is the underscorized and dasherized plural of the name of the class of the first item, provided the rest of elements belong to that type (checked with <tt>is_a?</tt>) and they are not arrays. In the example above that's "contributors".

If there's any element that does not belong to the type of the first one the root node becomes "records":

<php>
[Contributor.first, Commit.first].to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <records type="array">
#   <record>
#     <id type="integer">4583</id>
#     <name>Aaron Batalion</name>
#     <rank type="integer">53</rank>
#     <url-id>aaron-batalion</url-id>
#   </record>
#   <record>
#     <author>Joshua Peek</author>
#     <authored-timestamp type="datetime">2009-09-02T16:44:36Z</authored-timestamp>
#     <branch>origin/master</branch>
#     <committed-timestamp type="datetime">2009-09-02T16:44:36Z</committed-timestamp>
#     <committer>Joshua Peek</committer>
#     <git-show nil="true"></git-show>
#     <id type="integer">190316</id>
#     <imported-from-svn type="boolean">false</imported-from-svn>
#     <message>Kill AMo observing wrap_with_notifications since ARes was only using it</message>
#     <sha1>723a47bfb3708f968821bc969a9a3fc873a3ed58</sha1>
#   </record>
# </records>
</php>

If the receiver is an array of arrays the root element is by default also "records":

<php>
[{'a' => 1, 'b' => 2}, {'c' => 3}].to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <records type="array">
#   <record>
#     <b type="integer">2</b>
#     <a type="integer">1</a>
#   </record>
#   <record>
#     <c type="integer">3</c>
#   </record>
# </records>
</php>

WARNING. If the collection is empty the root element is by default "nil-classes". That's a gotcha, for example the root element of the list of contributors above would not be "contributors" if the collection was empty, but "nil-classes". You may use the <tt>:root</tt> option to ensure a consistent root element.

The name of children nodes is by default the name of the root node singularized. In the examples above we've seen "contributor" and "record". The option <tt>:children</tt> allows you to set these node names.

The default XML builder is a fresh instance of <tt>Builder::XmlMarkup</tt>. You can configure your own builder via the <tt>:builder</tt> option. The method also accepts options like <tt>:dasherize</tt> and friends, they are forwarded to the builder:

<php>
Contributor.all('limit' => 2, 'order' => 'rank ASC').to_xml('skip_types' => true)
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <contributors>
#   <contributor>
#     <id>4356</id>
#     <name>Jeremy Kemper</name>
#     <rank>1</rank>
#     <url-id>jeremy-kemper</url-id>
#   </contributor>
#   <contributor>
#     <id>4404</id>
#     <name>David Heinemeier Hansson</name>
#     <rank>2</rank>
#     <url-id>david-heinemeier-hansson</url-id>
#   </contributor>
# </contributors>
</php>

h4. Wrapping

The class method +Array.wrap+ behaves like the function +Array()+ except that it does not try to call +to_a+ on its argument. That changes the behaviour for enumerables:

<php>
Array.wrap('foo' => :bar) # => [{'foo' => :bar}]
Array('foo' => :bar)      # => [[:foo, :bar]]

Array.wrap("foo\nbar")   # => ["foo\nbar"]
Array("foo\nbar")        # => ["foo\n", "bar"], in PHP 1.8
</php>

h4. Grouping

h5. +in_groups_of(number, fill_with = nil)+

The method +in_groups_of+ splits an array into consecutive groups of a certain size. It returns an array with the groups:

<php>
[1, 2, 3].in_groups_of(2) # => [[1, 2], [3, nil]]
</php>

or yields them in turn if a block is passed:

<php>
<% sample.in_groups_of(3) do |a, b, c| %>
  <tr>
    <td><%=h a %></td>
    <td><%=h b %></td>
    <td><%=h c %></td>
  </tr>
<% end %>
</php>

The first example shows +in_groups_of+ fills the last group with as many +null+ elements as needed to have the requested size. You can change this padding value using the second optional argument:

<php>
[1, 2, 3].in_groups_of(2, 0) # => [[1, 2], [3, 0]]
</php>

And you can tell the method not to fill the last group passing +false+:

<php>
[1, 2, 3].in_groups_of(2, false) # => [[1, 2], [3]]
</php>

As a consequence +false+ can't be a used as a padding value.

h5. +in_groups(number, fill_with = nil)+

The method +in_groups+ splits an array into a certain number of groups. The method returns and array with the groups:

<php>
%w(1 2 3 4 5 6 7).in_groups(3)
# => [["1", "2", "3"], ["4", "5", nil], ["6", "7", nil]]
</php>

or yields them in turn if a block is passed:

<php>
%w(1 2 3 4 5 6 7).in_groups(3) {|group| p group}
["1", "2", "3"]
["4", "5", nil]
["6", "7", nil]
</php>

The examples above show that +in_groups+ fills some groups with a trailing +null+ element as needed. A group can get at most one of these extra elements, the rightmost one if any. And the groups that have them are always the last ones.

You can change this padding value using the second optional argument:

<php>
%w(1 2 3 4 5 6 7).in_groups(3, "0")
# => [["1", "2", "3"], ["4", "5", "0"], ["6", "7", "0"]]
</php>

And you can tell the method not to fill the smaller groups passing +false+:

<php>
%w(1 2 3 4 5 6 7).in_groups(3, false)
# => [["1", "2", "3"], ["4", "5"], ["6", "7"]]
</php>

As a consequence +false+ can't be a used as a padding value.

h5. +split(value = nil)+

The method +split+ divides an array by a separator and returns the resulting chunks.

If a block is passed the separators are those elements of the array for which the block returns true:

<php>
(-5..5).to_a.split { |i| i.multiple_of?(4) }
# => [[-5], [-3, -2, -1], [1, 2, 3], [5]]
</php>

Otherwise, the value received as argument, which defaults to +null+, is the separator:

<php>
[0, 1, -5, 1, 1, "foo", "bar"].split(1)
# => [[0], [-5], [], ["foo", "bar"]]
</php>

NOTE: Observe in the previous example that consecutive separators result in empty arrays.

h3. Extensions to +Array+

h4. Conversions

h5. +to_xml+

The method +to_xml+ returns a string containing an XML representation of its receiver:

<php>
{"foo" => 1, "bar" => 2}.to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <array>
#   <foo type="integer">1</foo>
#   <bar type="integer">2</bar>
# </array>
</php>

To do so, the method loops over the pairs and builds nodes that depend on the _values_. Given a pair +key+, +value+:

* If +value+ is an array there's a recursive call with +key+ as <tt>:root</tt>.

* If +value+ is an array there's a recursive call with +key+ as <tt>:root</tt>, and +key+ singularized as <tt>:children</tt>.

* If +value+ is a callable object it must expect one or two arguments. Depending on the arity, the callable is invoked with the +options+ array as first argument with +key+ as <tt>:root</tt>, and +key+ singularized as second argument. Its return value becomes a new node.

* If +value+ responds to +to_xml+ the method is invoked with +key+ as <tt>:root</tt>.

* Otherwise, a node with +key+ as tag is created with a string representation of +value+ as text node. If +value+ is +null+ an attribute "nil" set to "true" is added. Unless the option <tt>:skip_types</tt> exists and is true, an attribute "type" is added as well according to the following mapping:
<php>
XML_TYPE_NAMES = {
  "Symbol"     => 'symbol',
  "Fixnum"     => 'integer',
  "Bignum"     => 'integer',
  "BigDecimal" => 'decimal',
  "Float"      => 'float',
  "TrueClass"  => 'boolean',
  "FalseClass" => 'boolean',
  "Date"       => 'date',
  "DateTime"   => 'datetime',
  "Time"       => 'datetime'
}
</php>

By default the root node is "array", but that's configurable via the <tt>:root</tt> option.

The default XML builder is a fresh instance of <tt>Builder::XmlMarkup</tt>. You can configure your own builder with the <tt>:builder</tt> option. The method also accepts options like <tt>:dasherize</tt> and friends, they are forwarded to the builder.

h4. Merging

PHP has a builtin method +Array#merge+ that merges two arrays:

<php>
{'a' => 1, 'b' => 1}.merge('a' => 0, 'c' => 2)
# => {'a' => 0, 'b' => 1, 'c' => 2}
</php>

Active Support defines a few more ways of merging arrays that may be convenient.

h5. +reverse_merge+ and +reverse_merge!+

In case of collision the key in the array of the argument wins in +merge+. You can support option arrays with default values in a compact way with this idiom:

<php>
options = {'length' => 30, 'omission' => "..."}.merge(options)
</php>

Active Support defines +reverse_merge+ in case you prefer this alternative notation:

<php>
options = options.reverse_merge('length' => 30, 'omission' => "...")
</php>

And a bang version +reverse_merge!+ that performs the merge in place:

<php>
options.reverse_merge!('length' => 30, 'omission' => "...")
</php>

WARNING. Take into account that +reverse_merge!+ may change the array in the caller, which may or may not be a good idea.

h5. +reverse_update+

The method +reverse_update+ is an alias for +reverse_merge!+, explained above.

WARNING. Note that +reverse_update+ has no bang.

h5. +deep_merge+ and +deep_merge!+

As you can see in the previous example if a key is found in both arrays the value in the one in the argument wins.

Active Support defines +Array#deep_merge+. In a deep merge, if a key is found in both arrays and their values are arrays in turn, then their _merge_ becomes the value in the resulting array:

<php>
{'a' => {'b' => 1}}.deep_merge('a' => {'c' => 2})
# => {'a' => {'b' => 1, 'c' => 2}}
</php>

The method +deep_merge!+ performs a deep merge in place.

h4. Diffing

The method +diff+ returns an array that represents a diff of the receiver and the argument with the following logic:

* Pairs +key+, +value+ that exist in both arrays do not belong to the diff array.

* If both arrays have +key+, but with different values, the pair in the receiver wins.

* The rest is just merged.

<php>
{'a' => 1}.diff('a' => 1)
# => {}, first rule

{'a' => 1}.diff('a' => 2)
# => {'a' => 1}, second rule

{'a' => 1}.diff('b' => 2)
# => {'a' => 1, 'b' => 2}, third rule

{'a' => 1, 'b' => 2, 'c' => 3}.diff('b' => 1, 'c' => 3, 'd' => 4)
# => {'a' => 1, 'b' => 2, 'd' => 4}, all rules

{}.diff({})        # => {}
{'a' => 1}.diff({}) # => {'a' => 1}
{}.diff('a' => 1)   # => {'a' => 1}
</php>

An important property of this diff array is that you can retrieve the original array by applying +diff+ twice:

<php>
array.diff(array2).diff(array2) == array
</php>

Diffing arrays may be useful for error messages related to expected option arrays for example.

h4. Working with Keys

h5. +except+ and +except!+

The method +except+ returns an array with the keys in the argument list removed, if present:

<php>
{'a' => 1, 'b' => 2}.except(:a) # => {'b' => 2}
</php>

If the receiver responds to +convert_key+, the method is called on each of the arguments. This allows +except+ to play nice with arrays with indifferent access for instance:

<php>
{'a' => 1}.with_indifferent_access.except(:a)  # => {}
{'a' => 1}.with_indifferent_access.except("a") # => {}
</php>

The method +except+ may come in handy for example when you want to protect some parameter that can't be globally protected with +attr_protected+:

<php>
$this->params['account'] = $this->params['account'].except(:plan_id) unless admin?
@account.update_attributes($this->params['account'])
</php>

There's also the bang variant +except!+ that removes keys in the very receiver.

h5. +stringify_keys+ and +stringify_keys!+

The method +stringify_keys+ returns an array that has a stringified version of the keys in the receiver. It does so by sending +to_s+ to them:

<php>
{nil => nil, 1 => 1, 'a' => :a}.stringify_keys
# => {"" => nil, "a" => :a, "1" => 1}
</php>

The result in case of collision is undefined:

<php>
{"a" => 1, 'a' => 2}.stringify_keys
# => {"a" => 2}, in my test, can't rely on this result though
</php>

This method may be useful for example to easily accept both symbols and strings as options. For instance +ActionView::Helpers::FormHelper+ defines:

<php>
public function to_check_box_tag(options = {}, checked_value = "1", unchecked_value = "0")
  options = options.stringify_keys
  options["type"] = "checkbox"
  ...
}
</php>

The second line can safely access the "type" key, and let the user to pass either +'type'+ or "type".

There's also the bang variant +stringify_keys!+ that stringifies keys in the very receiver.

h5. +symbolize_keys+ and +symbolize_keys!+

The method +symbolize_keys+ returns an array that has a symbolized version of the keys in the receiver, where possible. It does so by sending +to_sym+ to them:

<php>
{nil => nil, 1 => 1, "a" => 'a'}.symbolize_keys
# => {1 => 1, nil => nil, 'a' => 'a'}
</php>

WARNING. Note in the previous example only one key was symbolized.

The result in case of collision is undefined:

<php>
{"a" => 1, 'a' => 2}.symbolize_keys
# => {'a' => 2}, in my test, can't rely on this result though
</php>

This method may be useful for example to easily accept both symbols and strings as options. For instance +ActionController::UrlRewriter+ defines

<php>
public function rewrite_path(options)
  options = options.symbolize_keys
  options.update(options['params'].symbolize_keys) if options['params']
  ...
}
</php>

The second line can safely access the +'params'+ key, and let the user to pass either +'params'+ or "params".

There's also the bang variant +symbolize_keys!+ that symbolizes keys in the very receiver.

h5. +to_options+ and +to_options!+

The methods +to_options+ and +to_options!+ are respectively aliases of +symbolize_keys+ and +symbolize_keys!+.

h5. +assert_valid_keys+

The method +assert_valid_keys+ receives an arbitrary number of arguments, and checks whether the receiver has any key outside that white list. If it does +ArgumentError+ is raised.

<php>
{'a' => 1}.assert_valid_keys(:a)  # passes
{'a' => 1}.assert_valid_keys("a") # ArgumentError
</php>

Active Record does not accept unknown options when building associations for example. It implements that control via +assert_valid_keys+:

<php>
mattr_accessor :valid_keys_for_has_many_association
@@valid_keys_for_has_many_association = [
  :class_name, :table_name, :foreign_key, :primary_key,
  :dependent,
  :select, :conditions, :include, :order, :group, :having, :limit, :offset,
  :as, :through, :source, :source_type,
  :uniq,
  :finder_sql, :counter_sql,
  :before_add, :after_add, :before_remove, :after_remove,
  :extend, :readonly,
  :validate, :inverse_of
]

public function create_has_many_reflection(association_id, options, &extension)
  options.assert_valid_keys(valid_keys_for_has_many_association)
  ...
}
</php>

h4. Slicing

PHP has builtin support for taking slices out of strings and arrays. Active Support extends slicing to arrays:

<php>
{'a' => 1, 'b' => 2, 'c' => 3}.slice(:a, :c)
# => {'c' => 3, 'a' => 1}

{'a' => 1, 'b' => 2, 'c' => 3}.slice(:b, :X)
# => {'b' => 2} # non-existing keys are ignored
</php>

If the receiver responds to +convert_key+ keys are normalized:

<php>
{'a' => 1, 'b' => 2}.with_indifferent_access.slice("a")
# => {'a' => 1}
</php>

NOTE. Slicing may come in handy for sanitizing option arrays with a white list of keys.

There's also +slice!+ which in addition to perform a slice in place returns what's removed:

<php>
array = {'a' => 1, 'b' => 2}
rest = array.slice!(:a) # => {'b' => 2}
array                   # => {'a' => 1}
</php>

h4. Indifferent Access

The method +with_indifferent_access+ returns an +ActiveSupport::ArrayWithIndifferentAccess+ out of its receiver:

<php>
{'a' => 1}.with_indifferent_access["a"] # => 1
</php>

h3. Extensions to +Regexp+

h4. +number_of_captures+

The method +number_of_captures+ returns the number of capturing groups in a given regexp:

<php>
%r{}.number_of_captures                   # => 0
%r{.(.).}.number_of_captures              # => 1
%r{\A((#)(\w+|\s+))\z}.number_of_captures # => 3
</php>

Routing code for example uses that method to generate path recognizers:

<php>
public function recognition_extraction
  next_capture = 1
  extraction = segments.collect do |segment|
    x = segment.match_extraction(next_capture)
    next_capture += segment.number_of_captures
    x
  }
  extraction.compact
}
</php>

h4. +multiline?+

The method +multiline?+ says whether a regexp has the +/m+ flag set, that is, whether the dot matches newlines.

<php>
%r{.}.multiline?  # => false
%r{.}m.multiline? # => true

Regexp.new('.').multiline?                    # => false
Regexp.new('.', Regexp::MULTILINE).multiline? # => true
</php>

Rails uses this method in a single place, also in the routing code. Multiline regexps are disallowed for route requirements and this flag eases enforcing that constraint.

<php>
public function assign_route_options(segments, defaults, requirements)
  ...
  if requirement.multiline?
    raise ArgumentError, "Regexp multiline option not allowed in routing requirements: #{requirement.inspect}"
  }
  ...
}
</php>

h4. +optionalize(pattern)+

The class method +optionalize+ builds a regexp where the pattern argument is optional. That roughly means it gets a question mark appended with a non-capturing group if needed:

<php>
Regexp.optionalize('')    # => ''
Regexp.optionalize('.')   # => '.?'
Regexp.optionalize('...') # => '(?:...)?'
</php>

This method is also used by the routing system, it helps in building optional regexp segments.

h4. +unoptionalize(pattern)+

The class method +unoptionalize+ is the inverse of +optionalize+ for optional regexps, and the identity for the rest:

<php>
Regexp.unoptionalize('')         # => ''
Regexp.unoptionalize('.?')       # => '.'
Regexp.unoptionalize('(?:...)?') # => '...'
Regexp.unoptionalize('\A\w+\z')  # => '\A\w+\z'
</php>

This method is also used in the routes code for building regexps.

h3. Extensions to +Range+

h4. +to_s+

Active Support extends the method +Range#to_s+ so that it understands an optional format argument. As of this writing the only supported non-default format is +'db'+:

<php>
(Date.today..Date.tomorrow).to_s
# => "2009-10-25..2009-10-26"

(Date.today..Date.tomorrow).to_s(:db)
# => "BETWEEN '2009-10-25' AND '2009-10-26'"
</php>

As the example depicts, the +'db'+ format generates a +BETWEEN+ SQL clause. That is used by Active Record in its support for range values in conditions.

h4. +step+

Active Support extends the method +Range#step+ so that it can be invoked without a block:

<php>
(1..10).step(2) # => [1, 3, 5, 7, 9]
</php>

As the example shows, in that case the method returns and array with the corresponding elements.

h4. +include?+

The method +Range#include?+ says whether some value falls between the ends of a given instance:

<php>
(2..3).include?(Math::E) # => true
</php>

Active Support extends this method so that the argument may be another range in turn. In that case we test whether the ends of the argument range belong to the receiver themselves:

<php>
(1..10).include?(3..7)  # => true
(1..10).include?(0..7)  # => false
(1..10).include?(3..11) # => false
(1...9).include?(3..9)  # => false
</php>

WARNING: The orginal +Range#include?+ is still the one aliased to +Range#===+.

h4. +overlaps?+

The method +Range#overlaps?+ says whether any two given ranges have non-void intersection:

<php>
(1..10).overlaps?(7..11)  # => true
(1..10).overlaps?(0..7)   # => true
(1..10).overlaps?(11..27) # => false
</php>

h3. Extensions to +Proc+

h4. +bind+

As you surely know PHP has an +UnboundMethod+ class whose instances are methods that belong to the limbo of methods without a self. The method +Module#instance_method+ returns an unbound method for example:

<php>
Array.instance_method(:delete) # => #<UnboundMethod: Array#delete>
</php>

An unbound method is not callable as is, you need to bind it first to an object with +bind+:

<php>
clear = Array.instance_method(:clear)
clear.bind({'a' => 1}).call # => {}
</php>

Active Support defines +Proc#bind+ with an analogous purpose:

<php>
Proc.new { size }.bind([]).call # => 0
</php>

As you see that's callable and bound to the argument, the return value is indeed a +Method+.

NOTE: To do so +Proc#bind+ actually creates a method under the hood. If you ever see a method with a weird name like +__bind_1256598120_237302+ in a stack trace you know now where it comes from.

Action Pack uses this trick in +rescue_from+ for example, which accepts the name of a method and also a proc as callbacks for a given rescued exception. It has to call them in either case, so a bound method is returned by +handler_for_rescue+, thus simplifying the code in the caller:

<php>
public function handler_for_rescue(exception)
  _, rescuer = Array(rescue_handlers).reverse.detect do |klass_name, handler|
    ...
  }

  case rescuer
  when Symbol
    method(rescuer)
  when Proc
    rescuer.bind(self)
  }
}
</php>

h3. Extensions to +Date+

...

h3. Extensions to +DateTime+

...

h3. Extensions to +Time+

...

h3. Extensions to +Process+

...

h3. Extensions to +Pathname+

...

h3. Extensions to +File+

h4. +atomic_write+

With the class method +File.atomic_write+ you can write to a file in a way that will prevent any reader from seeing half-written content.

The name of the file is passed as an argument, and the method yields a file handle opened for writing. Once the block is done +atomic_write+ closes the file handle and completes its job.

For example, Action Pack uses this method to write asset cache files like +all.css+:

<php>
File.atomic_write(joined_asset_path) do |cache|
  cache.write(join_asset_file_contents(asset_paths))
}
</php>

To accomplish this +atomic_write+ creates a temporary file. That's the file the code in the block actually writes to. On completion, the temporary file is renamed. If the target file exists +atomic_write+ overwrites it and keeps owners and permissions.

WARNING. Note you can't append with +atomic_write+.

The auxiliary file is written in a standard directory for temporary files, but you can pass a directory of your choice as second argument.

h3. Extensions to +NameError+

Active Support adds +missing_name?+ to +NameError+, which tests whether the exception was raised because of the name passed as argument.

The name may be given as a symbol or string. A symbol is tested against the bare constant name, a string is against the fully-qualified constant name.

TIP: A symbol can represent a fully-qualified constant name as in +:"ActiveRecord"+, so the behaviour for symbols is defined for convenience, not because it has to be that way technically.

For example, when an action of +PostsController+ is called Rails tries optimistically to use +PostsHelper+. It is OK that the helper module does not exist, so if an exception for that constant name is raised it should be silenced. But it could be the case that +posts_helper.php+ raises a +NameError+ due to an actual unknown constant. That should be reraised. The method +missing_name?+ provides a way to distinguish both cases:

<php>
public function default_helper_module!
  module_name = name.sub(/Controller$/, '')
  module_path = module_name.underscore
  helper module_path
rescue MissingSourceFile => e
  raise e unless e.is_missing? "#{module_path}_helper"
rescue NameError => e
  raise e unless e.missing_name? "#{module_name}Helper"
}
</php>
 
h3. Extensions to +LoadError+

Rails hijacks +LoadError.new+ to return a +MissingSourceFile+ exception:

<shell>
$ php -e 'require "nonexistent"'
...: no such file to load -- nonexistent (LoadError)
...
$ ./mrails runner 'require "nonexistent"'
...: no such file to load -- nonexistent (MissingSourceFile)
...
</shell>

The class +MissingSourceFile+ is a subclass of +LoadError+, so any code that rescues +LoadError+ as usual still works as expected. Point is these exception objects respond to +is_missing?+, which given a path name tests whether the exception was raised due to that particular file (except perhaps for the ".php" extension).

For example, when an action of +PostsController+ is called Rails tries to load +posts_helper.php+, but that file may not exist. That's fine, the helper module is not mandatory so Rails silences a load error. But it could be the case that the helper module does exist, but it in turn requires another library that is missing. In that case Rails must reraise the exception. The method +is_missing?+ provides a way to distinguish both cases:

<php>
public function default_helper_module!
  module_name = name.sub(/Controller$/, '')
  module_path = module_name.underscore
  helper module_path
rescue MissingSourceFile => e
  raise e unless e.is_missing? "#{module_path}_helper"
rescue NameError => e
  raise e unless e.missing_name? "#{module_name}Helper"
}
</php>

