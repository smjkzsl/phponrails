<?php

# This file is part of the PhpOnRails Framework
# (Copyright) 2010-2014 Bruce chou from bermi's  project
# See LICENSE and CREDITS for details

class AkActionController extends AkLazyObject
{
    const DEFAULT_RENDER_STATUS_CODE = null;

    public $locale_namespace;
    public $_high_load_mode = HIGH_LOAD_MODE;
    public $_enable_plugins = true;
    public $_auto_instantiate_models = true;
    public $validate_output = false;

    public $_ssl_requirement = false;
    public $_ssl_allowed_actions = array();
    public $ssl_for_all_actions = true;

    /**
    * Determines whether the view has access to controller internals $this->Request, $this->Response, $this->session, and $this->Template.
    * By default, it does.
    */
    public $_view_controller_internals = true;

    /**
    * Protected instance variable cache
    */
    public $_protected_variables_cache = array();

    /**
    * Prepends all the URL-generating helpers from AssetHelper.
    * This makes it possible to easily move javascripts, stylesheets,
    * and images to a dedicated asset server away from the main web server.
    * Example:
    *  $this->_asset_host = 'http://assets.example.com';
    */
    public $asset_host = ASSET_HOST;


    public $_Logger;

    /**
    * Determines which template class should be used by AkActionController.
    */
    public $TemplateClass;

    /**
    * Turn on +_ignore_missing_templates+ if you want to unit test actions without
    * making the associated templates.
    */
    public $_ignore_missing_templates;

    /**
    * Holds the Request object that's primarily used to get environment variables
    */
    public $Request;

    /**
    * Holds an array of all the GET, POST, and Url parameters passed to the action.
    * Accessed like <tt>$this->params['post_id'];</tt>
    * to get the post_id.
    */
    public $params = array();

    /**
    * Holds the Response object that's primarily used to set additional HTTP _headers
    * through access like <tt>$this->Response->_headers['Cache-Control'] = 'no-cache';</tt>.
    * Can also be used to access the final body HTML after a template
    * has been rendered through $this->Response->body -- useful for <tt>after_filter</tt>s
    * that wants to manipulate the output, such as a OutputCompressionFilter.
    */
    public $Response;

    /**
    * Holds an array of objects in the session. Accessed like <tt>$this->session['person']</tt>
    * to get the object tied to the 'person' key. The session will hold any type of object
    * as values, but the key should be a string.
    */
    public $session;

    /**
    * Holds an array of header names and values. Accessed like <tt>$this->_headers['Cache-Control']</tt>
    * to get the value of the Cache-Control directive. Values should always be specified as strings.
    */
    public $_headers = array();

    /**
    * Holds the array of variables that are passed on to the template class to be
    * made available to the view. This array is generated by taking a snapshot of
    * all the instance variables in the current scope just before a template is rendered.
    */
    public $_assigns = array();

    /**
    * Holds the name of the action this controller is processing.
    */
    public $_action_name;

    public $cookies;

    public $helpers = 'default';

    public $app_helpers;
    public $plugin_helpers = 'all';

    public $web_service;
    public $web_services = array();

    public $web_service_api;
    public $web_service_apis = array();

    public $module_name;

    public $_request_id = -1;

    public $filter_parameter_logging = array();
    public $skip_parameter_logging = array(SESSION_NAME, 'ak');

    protected

    $_module_path,
    $_report_undefined_attributes = false,
    $_dynamic_attributes = array(),
    $_dynamic_methods = array();

    public function __destruct() {
        $this->_disbaleLazyLoadingExtenssions();
    }


    public function process(&$Request, &$Response, $options = array()) {
        if(ENABLE_PROFILER) AkDebug::profile('AkActionController::process() start');

        $this->setRequestAndResponse($Request, $Response);

        if(LOG_EVENTS) $this->_logRequestParams($this->params);
        if(ENABLE_PROFILER) AkDebug::profile('Got request paramenters');
        
        $actionExists = $this->_ensureActionExists();

        if (!$actionExists) {
            $this->handleResponse();
            return false;
        }

        AkConfig::getLocalesReady();

        if($this->_high_load_mode !== true){
            if(!empty($this->_auto_instantiate_models)){
                $this->instantiateIncludedModelClasses();
                if(ENABLE_PROFILER) AkDebug::profile('Instantiated models');
            }
            if(!empty($this->_enable_plugins)){
                $this->loadPlugins();
                if(ENABLE_PROFILER)  AkDebug::profile('Instantiated plugins');
            }
        }

        $this->_ensureProperProtocol();

        $this->_lazy_loading_options = $options;
        //~ $this->init($options);

        // After filters
        //$this->isFilteringActive() && $this->afterFilter('_handleFlashAttribute');

        $this->_loadActionView();

        if(isset($this->api)){
            $this->aroundFilter(new AkActionWebService($this));
        }
	$this->_initCacheHandler();
        $this->_identifyRequest();

        if($this->isFilteringActive()){
            $this->performActionWithFilters($this->_action_name);
        }else{
            $this->performActionWithoutFilters($this->_action_name);
        }

        return $this->handleResponse();
    }

    protected function _enableLazyLoadingExtenssions($options = array()) {
        $options = empty($options) ? (empty($this->_lazy_loading_options) ? array() : $this->_lazy_loading_options) : $options;
        if(empty($options['skip_filters'])) $this->_enableFilters();
        if(empty($options['skip_authentication'])) $this->_enableAuthentication();
    }

    protected function _disbaleLazyLoadingExtenssions() {
        $this->_disableFilters();
    }

    // Authentication
    protected function _enableAuthentication() {
        $this->extendClassLazily('AkControllerAuthentication',
        array(
        'methods' => array(
        'authenticateOrRequestWithHttpBasic','authenticateWithHttpBasic','requestHttpBasicAuthentication',
        'authenticateOrRequestWithHttpDigest','authenticateWithHttpDigest','requestHttpDigestAuthentication'
        ),
        'autoload_path' => ACTION_PACK_DIR.DS.'controller_authentication.php'
        ));
    }

    // Action Filtering
    protected function _enableFilters() {
        $this->extendClassLazily('AkControllerFilter',
        array(
        'init_method' => 'setObjectBeenFiltered',
        'methods_match' => '/(((after|before|perform)Action)|(.+Filter.*))/',
        'autoload_path' => ACTION_PACK_DIR.DS.'controller_filter.php'
        ));
    }

    protected function _disableFilters() {
        $this->unregisterExtenssion('AkControllerFilter');
    }

    public function isFilteringActive() {
        return $this->hasInstantiatedClass('AkControllerFilter');
    }

    public function performActionWithoutFilters($action) {
        if(method_exists($this, $action)){
            call_user_func_array(array($this, $action), @(array)$this->passed_args);
        }
    }

    public function _sendMimeContentType() {
        $this->Response->setContentTypeForFormat($this->Request->getFormat());
    }

    /**
     * Used to respond to multiple formats on the same action.
     * The format gets detected by the requested file extension or the
     * accept headers.
     *
     * Example 1:
     * If you need to perform some calculations inste
     * ----
     *
     * function listing()
     * {
     *    $this->listings = $this->listing->find(..);
     *    if (!$this->respondToFormat()) {
     *        // default html response here
     *    }
     * }
     * // handles action listing in format xml
     * function _handleListingAsXml()
     * {
     *    $this->renderText($this->listing->toXml($this->listings));
     * }
     *
     *
     * Example 2:
     * If you just render a standard template by default
     *
     * function listing()
     * {
     *    // if its the standard format it will render the template post.tpl
     *    $this->respondToFormat();
     * }
     * // handles action listing in format xml
     * function _handleListingAsXml()
     * {
     *    $this->renderText($this->listing->toXml($this->listings));
     * }
     *
     * @param array $options
     * @return boolean true if there is a format action, false if not
     */
    public function respondToFormat($options = array()) {
        $default_options = array('default'=>'html');

        $options = array_merge($default_options,$options);

        $format = $this->Request->getFormat();
        $action = $this->getActionName();
        $formatAction = '_handle'.$action.'As'.ucfirst($format);
        $isDefaultAction = $format == null || $format == $options['default'];
        $formatActionExists = method_exists($this,$formatAction);
        if (!$formatActionExists && !$isDefaultAction) {
            $this->renderText('404 Not found',404);

        }
        if (!$isDefaultAction && $formatActionExists) {
            $this->performActionWithoutFilters($formatAction);
            return true;
        }
        return false;
    }

    public function _identifyRequest() {
        $this->_request_id = Ak::uuid();
    }

    public function handleResponse() {
        static $handled;
        if (empty($handled)) {
            $handled = array();
        }
        if (!isset($handled[$this->_request_id])) {
            if (!$this->hasPerformed()){
                $this->defaultRender();
            }
            if (!isset($this->Response->_headers['Content-Type'])) {
                $this->_sendMimeContentType();
            }
            if (!isset($this->Response->_headers['Status']) && !empty($this->_default_render_status_code)) {
                $this->Response->_headers['Status'] = $this->_default_render_status_code;
            }
            $this->_closeSession();
            $this->Response->outputResults();
            if(LOG_EVENTS && isset($this->ak_time_start)){
                $this->_log('Completed in '.(microtime(true)-$this->ak_time_start));
            }
            $handled[$this->_request_id] = true;
        }
    }

    public function setRequestAndResponse($Request,$Response) {
        $this->Request      = $Request;
        $this->Response     = $Response;
        $this->params       = $this->Request->getParams();
        $this->_action_name = $this->Request->getAction();
    }

    public function loadTemplateHandler($force_reload = false){
        if(empty($this->Template) || $force_reload){
            $this->Template = new AkActionView(
            $this->_getTemplateBasePath(),
            $this->Request->getParameters(),
            $this);
            $this->Template->registerTemplateHandler('tpl','AkPhpTemplateHandler');
            //we register a handler for the '.html.tpl' extension, so its optional to
            //use the html-extension in template filenames. use index.tpl <=or=> index.html.tpl
            $this->Template->registerTemplateHandler('html.tpl','AkPhpTemplateHandler');

            $this->Template->setHelperLoader($this->getHelperLoader());
        }
    }

    public function loadPlugins() {
        Ak::loadPlugins();
    }

    private function _loadActionView() {
        empty($this->_assigns) ? ($this->_assigns = array()) : null;
        $this->passed_args = !isset($this->Request->pass)? array() : $this->Request->pass;
        empty($this->cookies) && isset($_COOKIE) ? ($this->cookies = $_COOKIE) : null;
        $this->loadTemplateHandler();
    }

    public function getCurrentControllerHelper() {
        $helper = $this->getControllerName();
        $helper = AkInflector::is_plural($helper)?AkInflector::singularize($helper):$helper;
        $helper_file_name = AkConfig::getDir('helpers').DS.$this->getModulePath().AkInflector::underscore($helper).'_helper.php';

        if(file_exists($helper_file_name)){
            return array($helper_file_name => $helper);
        }
        return array();
    }

    public function getModuleHelper(){
        $module_name = $this->getModuleName();
        if(!empty($module_name)){
            $helper_file_name = AkConfig::getDir('helpers').DS.AkInflector::underscore($module_name).'_helper.php';
            if(file_exists($helper_file_name)){
                return array($helper_file_name => $module_name);
            }
        }
        return array();
    }

    public function getModulePath(){
        return $this->_module_path;
    }

    public function setModulePath($module_path){
        $this->_module_path = $module_path;
    }


    /**
                        Automatic model loading
    ====================================================================
    */

    /**
     * Methods for loading desired models into this controller
     */
    public function setModel($model) {
        $this->instantiateIncludedModelClasses(array($model));
    }

    public function setModels($models) {
        $this->instantiateIncludedModelClasses($models);
    }

    public function instantiateIncludedModelClasses($models = array()) {
        $models = $this->getIncludedModelClassNames($models);
        unset($this->model, $this->models);
        foreach ($models as $model){
            $this->instantiateModelClass($model);
        }
    }

    public function getIncludedModelClassNames($extra_models = array()) {
        if(empty($this->model))      $this->model      = $this->getControllerName();
        if(empty($this->models))     $this->models     = array();
        if(empty($this->app_models)) $this->app_models = array();
        return (array)array_unique(array_diff(array_merge_recursive(Ak::toArray($extra_models), Ak::toArray($this->app_models), Ak::toArray($this->models), Ak::toArray($this->model)), array('')));
    }

    function getFinderOptionsForClassName($model_class_name) {
        if(!empty($this->finder_options[$model_class_name])){
            return $this->finder_options[$model_class_name];
        }elseif (method_exists($this, '_getFinderOptions') && empty($this->finder_options[$model_class_name])) {
            return $this->_getFinderOptions($model_class_name);
        }
        return array();
    }

    public function instantiateModelClass($model_class_name, $finder_options = array(), $custom_find = false) {

        if(!$model_class_name = Ak::import($model_class_name)){
            return false;
        }

        $model_class_name = Ak::first($model_class_name);
        $finder_options = empty($finder_options) ? $this->getFinderOptionsForClassName($model_class_name) : $finder_options;

        $underscored_model_class_name = AkInflector::underscore($model_class_name);
        $controller_name = isset($this->controller_name) ? $this->controller_name : $this->getControllerName();
        $id = empty($this->params[$underscored_model_class_name]['id']) ?(empty($this->params['id']) ? false : (($model_class_name == $controller_name || $model_class_name == $this->singularized_controller_name) ? $this->params['id'] : false)) : $this->params[$underscored_model_class_name]['id'];

        $underscored_model_class_name = AkInflector::underscore($model_class_name);

        if(!isset($this->$model_class_name) || !isset($this->$underscored_model_class_name)){

            if($finder_options !== false && is_numeric($id)){
                $model = new $model_class_name();
                if(empty($finder_options)){
                    $model = $model->find($id);
                }elseif ($custom_find) {
                    $model = $model->find('first', $finder_options);
                }else{
                    $model = $model->find($id, $finder_options);
                }
            }else{
                $model = new $model_class_name();
            }
            if(!isset($this->$model_class_name)){
                $this->$model_class_name = $model;
            }
            if(!isset($this->$underscored_model_class_name)){
                $this->$underscored_model_class_name = $model;
            }
        }
        return true;
    }



    /**
                            Rendering content
    ====================================================================
    */

    /**
    * Renders the content that will be returned to the browser as the Response body.
    *
    * === Rendering an action
    *
    * Action rendering is the most common form and the type used automatically by
    * Action Controller when nothing else is specified. By default, actions are
    * rendered within the current layout (if one exists).
    *
    * * Renders the template for the action "goal" within the current controller
    *
    *       $this->render(array('action'=>'goal'));
    *
    * * Renders the template for the action "short_goal" within the current controller,
    *   but without the current active layout
    *
    *       $this->render(array('action'=>'short_goal','layout'=>false));
    *
    * * Renders the template for the action "long_goal" within the current controller,
    *   but with a custom layout
    *
    *       $this->render(array('action'=>'long_goal','layout'=>'spectacular'));
    *
    * === Rendering partials
    *
    * Partial rendering is most commonly used together with Ajax calls that only update
    * one or a few elements on a page without reloading. Rendering of partials from
    * the controller makes it possible to use the same partial template in
    * both the full-page rendering (by calling it from within the template) and when
    * sub-page updates happen (from the controller action responding to Ajax calls).
    * By default, the current layout is not used.
    *
    * * Renders the partial located at app/views/controller/_win.tpl
    *
    *       $this->render(array('partial'=>'win'));
    *
    * * Renders the partial with a status code of 500 (internal error)
    *
    *       $this->render(array('partial'=>'broken','status'=>500));
    *
    * * Renders the same partial but also makes a local variable available to it
    *
    *       $this->render(array('partial' => 'win', 'locals' => array('name'=>'david')));
    *
    * * Renders a collection of the same partial by making each element of $wins available through
    *   the local variable "win" as it builds the complete Response
    *
    *       $this->render(array('partial'=>'win','collection'=>$wins));
    *
    * * Renders the same collection of partials, but also renders the win_divider partial in between
    *   each win partial.
    *
    *       $this->render(array('partial'=>'win','collection'=>$wins,'spacer_template'=>'win_divider'));
    *
    * === Rendering a template
    *
    * Template rendering works just like action rendering except that it takes a
    * path relative to the template root.
    * The current layout is automatically applied.
    *
    * * Renders the template located in app/views/weblog/show.tpl
    *   $this->render(array('template'=>'weblog/show'));
    *
    * === Rendering a file
    *
    * File rendering works just like action rendering except that it takes a
    * filesystem path. By default, the path is assumed to be absolute, and the
    * current layout is not applied.
    *
    * * Renders the template located at the absolute filesystem path
    *   $this->render(array('file'=>'/path/to/some/template.tpl'));
    *   $this->render(array('file'=>'c:/path/to/some/template.tpl'));
    *
    * * Renders a template within the current layout, and with a 404 status code
    *   $this->render(array('file' => '/path/to/some/template.tpl', 'layout' => true, 'status' => 404));
    *   $this->render(array('file' => 'c:/path/to/some/template.tpl', 'layout' => true, 'status' => 404));
    *
    * * Renders a template relative to the template root and chooses the proper file extension
    *   $this->render(array('file' => 'some/template', 'use_full_path' => true));
    *
    *
    * === Rendering text
    *
    * Rendering of text is usually used for tests or for rendering prepared content,
    * such as a cache. By default, text
    * rendering is not done within the active layout.
    *
    * * Renders the clear text "hello world" with status code 200
    *   $this->render(array('text' => 'hello world!'));
    *
    * * Renders the clear text "Explosion!"  with status code 500
    *   $this->render(array('text' => "Explosion!", 'status' => 500 ));
    *
    * * Renders the clear text "Hi there!" within the current active layout (if one exists)
    *   $this->render(array('text' => "Explosion!", 'layout' => true));
    *
    * * Renders the clear text "Hi there!" within the layout
    * * placed in "app/views/layouts/special.tpl"
    *   $this->render(array('text' => "Explosion!", 'layout => "special"));
    *
    *
    * === Rendering an inline template
    *
    * Rendering of an inline template works as a cross between text and action
    * rendering where the source for the template
    * is supplied inline, like text, but its evaled by PHP, like action. By default,
    * PHP is used for rendering and the current layout is not used.
    *
    * * Renders "hello, hello, hello, again"
    *   $this->render(array('inline' => "<?php echo str_repeat('hello, ', 3).'again'?>" ));
    *
    * * Renders "hello david"
    *   $this->render(array('inline' => "<?php echo  'hello ' . $name ?>", 'locals' => array('name' => 'david')));
    *
    *
    * === Rendering nothing
    *
    * Rendering nothing is often convenient in combination with Ajax calls that
    * perform their effect client-side or
    * when you just want to communicate a status code. Due to a bug in Safari, nothing
    * actually means a single space.
    *
    * * Renders an empty Response with status code 200
    *   $this->render(array('nothing' => true));
    *
    * * Renders an empty Response with status code 401 (access denied)
    *   $this->render(array('nothing' => true, 'status' => 401));
    */
    public function render($options = null, $status = 200) {
        if(empty($options['inline']) && empty($options['partial']) && $this->hasPerformed()){
            $this->_doubleRenderError(Ak::t("Can only render or redirect once per action"));
            return false;
        }
        /**
         * need to check this with the caching!!!
         */
        $this->_flash_handled ? null : $this->_handleFlashAttribute();

        if(!is_array($options)){
            return $this->renderFile(empty($options) ? $this->getDefaultTemplateName() : $options, $status, true);
        }

        if(!empty($options['text'])){
            return $this->renderText($options['text'], @$options['status']);
        }else{

            if(!empty($options['file'])){
                return $this->renderFile($options['file'], @$options['status'], @$options['use_full_path'], @(array)$options['locals']);
            }elseif(!empty($options['template'])){
                return $this->renderFile($options['template'], @$options['status'], true);
            }elseif(!empty($options['inline'])){
                return $this->renderTemplate($options['inline'], @$options['status'], @$options['type'], @(array)$options['locals']);
            }elseif(!empty($options['action'])){
                return $this->renderAction($options['action'], @$options['status'], @$options['layout']);
            }elseif(!empty($options['partial'])){
                if($options['partial'] === true){
                    $options['partial'] = !empty($options['template']) ? $options['template'] : $this->getDefaultTemplateName();
                }
                if(isset($options['collection']) && is_array($options['collection'])){
                    return $this->renderPartialCollection($options['partial'], $options['collection'], @$options['spacer_template'], @$options['locals'], @$options['status']);
                }else{
                    return $this->renderPartial($options['partial'], @$options['object'], @$options['locals'], @$options['status']);
                }
            }elseif(!empty($options['xml'])){
                return $this->renderXml($options, @$options['status']);
            }elseif(!empty($options['json'])){
                return $this->renderJson($options, @$options['status']);
            }elseif(!empty($options['nothing'])){
                // Safari doesn't pass the _headers of the return if the Response is zero length
                return $this->renderText(' ', @$options['status']);
            }else{
                return $this->renderFile($this->getDefaultTemplateName(), @$options['status'], true);
            }
        }
    }

    /**
    * Renders according to the same rules as <tt>render</tt>, but returns the result in a string instead
    * of sending it as the Response body to the browser.
    */
    public function renderToString($options = null) {
        $result = $this->render($options);
        $this->eraseRenderResults();
        $this->variables_added = null;
        return $result;
    }

    public function renderAction($_action_name, $status = null, $with_layout = true) {
        $template = $this->getDefaultTemplateName($_action_name);
        if(!empty($with_layout) && !$this->_isTemplateExemptFromLayout($template)){
            return $this->renderWithLayout($template, $status, $with_layout);
        }else{
            return $this->renderWithoutLayout($template, $status);
        }
    }

    public function renderFile($template_path, $status = null, $use_full_path = false, $locals = array()) {
        $this->_addVariablesToAssigns();
        $locals = array_merge($locals,$this->_assigns);
        $template_exists = true;
        if($use_full_path){
            $template_exists = $this->_assertExistanceOfTemplateFile($template_path);
        }
        if(LOG_EVENTS && $template_exists) $this->_log("Rendering $template_path".(empty($status)?'':'('.$this->Response->getStatusDescription($status).')'));
        return $this->renderText($this->Template->renderFile($template_path, $use_full_path, $locals), $status);
    }

    public function renderTemplate($template, $status = null, $type = 'tpl', $local_assigns = array()) {
        $this->_addVariablesToAssigns();
        $local_assigns = array_merge($local_assigns, $this->_assigns);
        return $this->renderText($this->Template->renderTemplate($type, $template, null, $local_assigns), $status);
    }

    public function renderText($text = null,  $status = self::DEFAULT_RENDER_STATUS_CODE) {
        $this->performed_render = true;
        if($status != null) {
            $this->Response->_headers['Status'] = $status;
        }
        $this->Response->body = $text;
        return $text;
    }
    
    public function renderXml($options = array(),  $status = self::DEFAULT_RENDER_STATUS_CODE) {
        $this->performed_render = true;
        if($status != null) {
            $this->Response->_headers['Status'] = $status;
        }
        return $this->Response->body = $options['xml']->toXml();
    }
    
    public function renderJson($options = array(),  $status = self::DEFAULT_RENDER_STATUS_CODE) {
        $this->performed_render = true;
        if($status != null) {
            $this->Response->_headers['Status'] = $status;
        }
        return $this->Response->body = $options['json']->toJson();
    }

    public function renderNothing($status = null) {
        return $this->renderText(' ', $status);
    }

    public function renderPartial($partial_path = null, $object = null, $local_assigns = null, $status = null) {
        $partial_path = empty($partial_path) ? $this->getDefaultTemplateName() : $partial_path;
        $this->variables_added = false;
        $this->performed_render = false;
        $this->_addVariablesToAssigns();
        $this->Template->controller = $this;
        $this->$partial_path = $this->renderText($this->Template->renderPartial($partial_path, $object, array_merge($this->_assigns, (array)$local_assigns)), $status);
        return $this->$partial_path;
    }

    public function renderPartialCollection($partial_name, $collection, $partial_spacer_template = null, $local_assigns = null) {
        $this->_addVariablesToAssigns();
        $collection_name = AkInflector::pluralize($partial_name).'_collection';
        $result = $this->Template->renderPartialCollection($partial_name, $collection, $partial_spacer_template, $local_assigns);
        if(empty($this->$collection_name)){
            $this->$collection_name = $result;
        }
        $this->variables_added = false;
        $this->performed_render = false;

        return $result;
    }

    public function defaultRender() {
        return $this->_high_load_mode ? $this->renderWithoutLayout() : $this->renderWithLayout();
    }

    public function renderWithLayout($template_name = null, $status = null, $layout = null) {
        $template_name = empty($template_name) ? $this->getDefaultTemplateName() : $template_name;
        return $this->renderWithALayout($template_name, $status, $layout);
    }

    public function renderWithoutLayout($template_name = null, $status = null) {
        $template_name = empty($template_name) ? $this->getDefaultTemplateName() : $template_name;
        return $this->render($template_name, $status);
    }

    /**
    * Clears the rendered results, allowing for another render to be performed.
    */
    public function eraseRenderResults() {
        $this->Response->body = '';
        $this->performed_render = false;
        $this->variables_added = false;
    }

    public function _addVariablesToAssigns() {
        if(empty($this->variables_added)){
            $this->_addInstanceVariablesToAssigns();
            $this->variables_added = true;
        }
    }

    public function _addInstanceVariablesToAssigns() {
        $this->_protected_variables_cache = array_merge($this->_protected_variables_cache, $this->_getProtectedInstanceVariables());

        foreach (array_diff(array_keys(get_object_vars($this)), $this->_protected_variables_cache) as $attribute){
            if($attribute[0] != '_'){
                $this->_assigns[$attribute] = $this->$attribute;
            }
        }
    }

    public function _getProtectedInstanceVariables() {
        return !empty($this->_view_controller_internals) ?
        array('_assigns', 'performed_redirect', 'performed_render','db') :
        array('_assigns', 'performed_redirect', 'performed_render', 'session', 'cookies',
        'Template','db','helpers','models','layout','Response','Request',
        'params','passed_args');
    }


    /**
     * Use this to translate strings in the scope of your controller
     *
     * @see Ak::t
     */
    public function t($string, $array = null, $controller=null) {
        if(!$controller){
            if(defined('DEFAULT_LOCALE_NAMESPACE') &&  (DEFAULT_LOCALE_NAMESPACE))
                $lns=DEFAULT_LOCALE_NAMESPACE;
            else
                $lns=($this->locale_namespace) ? $this->locale_namespace : "views";
             $controller=AkConfig::getOption('locale_namespace',$lns);
        }
        return Ak::t($string, $array,$controller ? $controller : AkInflector::underscore($this->getControllerName()));
    }



    /**
                            Redirects
    ====================================================================
    */

    /**
    * Redirects the browser to the target specified in +options+. This parameter can take one of three forms:
    *
    * * <tt>Array</tt>: The URL will be generated by calling $this->urlFor with the +options+.
    * * <tt>String starting with protocol:// (like http://)</tt>: Is passed straight through
    * as the target for redirection.
    * * <tt>String not containing a protocol</tt>: The current protocol and host is prepended to the string.
    * * <tt>back</tt>: Back to the page that issued the Request-> Useful for forms that are
    * triggered from multiple places.
    *   Short-hand for redirectTo(Request->env["HTTP_REFERER"])
    *
    * Examples:
    *   redirectTo(array('action' => 'show', 'id' => 5));
    *   redirectTo('http://www.bermilabs.com');
    *   redirectTo('/images/screenshot.jpg');
    *   redirectTo('back');
    *
    * The redirection happens as a "302 Moved" header.
    */
    public function redirectTo($options = array(), $parameters_for_method_reference = null) {
        if($options instanceof AkBaseModel){
            $options = AkRouterHelper::getUrlParamsForModel($options);
        }
        
        $this->_handleFlashAttribute($parameters_for_method_reference);
        $this->_closeSession();

        if(is_string($options)) {
            if(preg_match('/^\w+:\/\/.*/',$options)){
                if($this->hasPerformed()){
                    $this->_doubleRenderError();
                }
                LOG_EVENTS && !empty($this->_Logger) ? $this->_Logger->message('Redirected to '.$options) : null;
                $this->Response->redirect($options);
                $this->Response->redirected_to = $options;
                $this->performed_redirect = true;
            }elseif ($options == 'back'){
                $this->redirectTo($this->Request->getReferer());
            }else{
                $this->redirectTo($this->Request->getProtocol(). $this->Request->getHostWithPort(). $options);
            }
        }else{
            if(empty($parameters_for_method_reference)){
                $this->redirectTo($this->urlFor($options));
                $this->Response->redirected_to = $options;
            }else{
                $this->redirectTo($this->urlFor($options, $parameters_for_method_reference));
                $this->Response->redirected_to = $options;
                $this->Response->redirected_to_method_params = $parameters_for_method_reference;
            }
        }
    }

    public function redirectToAction($action, $options = array()) {
        $this->redirectTo(array_merge(array('action'=>$action), $options));
    }

    public function getControllerName() {
        if(!isset($this->controller_name)){
            $current_class_name = str_replace('_', '::', get_class($this));
            $controller_name = substr($current_class_name,0,-10);
            $this->controller_name = $this->_removeModuleNameFromControllerName($controller_name);
            $this->singularized_controller_name = AkInflector::singularize($this->controller_name);
        }
        return $this->controller_name;
    }

    public function __getControllerName_PHP4_fix($class_name) {
        $included_controllers = $this->_getIncludedControllerNames();
        $lowercase_included_controllers = array_map('strtolower', $included_controllers);
        $key = array_search(strtolower($class_name), $lowercase_included_controllers, true);
        return $included_controllers[$key];
    }

    public function getModuleName(){
        if(empty($this->module_name)){
            $this->getControllerName(); // module name is set when we first retrieve the controller name
        }
        return $this->module_name;
    }

    public function setModuleName($module_name) {
        return $this->module_name = $module_name;
    }

    /**
     * Removes the modules name from the controller if exists and sets it.
     *
     * @return $controller_name
     */
    public function _removeModuleNameFromControllerName($controller_name) {
        if(strstr($controller_name, '::')){
            $module_parts = explode ('::',$controller_name);
            $controller_name = array_pop($module_parts);
            $this->setModuleName(join('/', array_map(array('AkInflector','underscore'), $module_parts)));
        }
        return $controller_name;
    }

    public function _getTemplateBasePath() {
        return AkConfig::getDir('app').DS.'views'.DS.(empty($this->_module_path)?'':$this->_module_path).$this->Request->getController();
    }

    public function _getIncludedControllerNames() {
        $controllers = array();
        foreach (get_included_files() as $file_name){
            if(strstr($file_name,AkConfig::getDir('controllers'))){
                $controllers[] = AkInflector::classify(str_replace(array(AkConfig::getDir('controllers').DS,'.php', DS, '//'),array('','','/', '/'),$file_name));
            }
        }
        return $controllers;
    }




    /**
                            URL generation/rewriting
    ====================================================================
    */


    /**
    * Overwrite to implement a number of default options that all urlFor-based methods will use.
    * The default options should come in
    * the form of a  an array, just like the one you would use for $this->urlFor directly. Example:
    *
    * function defaultUrlOptions($options)
    * {
    *     return array('project' => ($this->Project->isActive() ? $this->Project->url_name : 'unknown'));
    *  }
    *
    * As you can infer from the example, this is mostly useful for situations where you want to
    * centralize dynamic decisions about the urls as they stem from the business domain.
    * Please note that any individual $this->urlFor call can always override the defaults set
    * by this method.
    */
    public function defaultUrlOptions($options = array()) {
        return $options;
    }


    /**
    * Returns a URL that has been rewritten according to the options array and the defined Routes.
    * (For doing a complete redirect, use redirectTo).
    *
    * <tt>$this->urlFor</tt> is used to:
    *
    * All keys given to $this->urlFor are forwarded to the Route module, save for the following:
    * * <tt>anchor</tt> -- specifies the anchor name to be appended to the path. For example,
    *   <tt>$this->urlFor(array('controller' => 'posts', 'action' => 'show', 'id' => 10, 'anchor' => 'comments'</tt>
    *   will produce "/posts/show/10#comments".
    * * <tt>only_path</tt> --  if true, returns the absolute URL (omitting the protocol, host name, and port)
    * * <tt>trailing_slash</tt> --  if true, adds a trailing slash, as in "/archive/2005/". Note that this
    *   is currently not recommended since it breaks caching.
    * * <tt>host</tt> -- overrides the default (current) host if provided
    * * <tt>protocol</tt> -- overrides the default (current) protocol if provided
    *
    * The URL is generated from the remaining keys in the array. A URL contains two key parts: the <base> and a query string.
    * Routes composes a query string as the key/value pairs not included in the <base>.
    *
    * The default Routes setup supports a typical PhpOnRails Framework path of "controller/action/id"
    * where action and id are optional, with
    * action defaulting to 'index' when not given. Here are some typical $this->urlFor statements
    * and their corresponding URLs:
    *
    *   $this->urlFor(array('controller'=>'posts','action'=>'recent')); //  'proto://host.com/posts/recent'
    *   $this->urlFor(array('controller'=>'posts','action'=>'index')); // 'proto://host.com/posts'
    *   $this->urlFor(array('controller'=>'posts','action'=>'show','id'=>10)); // 'proto://host.com/posts/show/10'
    *
    * When generating a new URL, missing values may be filled in from the current
    * Request's parameters. For example,
    * <tt>$this->urlFor(array('action'=>'some_action'));</tt> will retain the current controller,
    * as expected. This behavior extends to other parameters, including <tt>controller</tt>,
    * <tt>id</tt>, and any other parameters that are placed into a Route's path.
    *
    * The URL helpers such as <tt>$this->urlFor</tt> have a limited form of memory:
    * when generating a new URL, they can look for missing values in the current Request's parameters.
    * Routes attempts to guess when a value should and should not be
    * taken from the defaults. There are a few simple rules on how this is performed:
    *
    * * If the controller name begins with a slash, no defaults are used: <tt>$this->urlFor(array('controller'=>'/home'));</tt>
    * * If the controller changes, the action will default to index unless provided
    *
    * The final rule is applied while the URL is being generated and is best illustrated by an example. Let us consider the
    * route given by <tt>map->connect('people/:last/:first/:action', array('action' => 'bio', 'controller' => 'people'))</tt>.
    *
    * Suppose that the current URL is "people/hh/david/contacts". Let's consider a few
    * different cases of URLs which are generated from this page.
    *
    * * <tt>$this->urlFor(array('action'=>'bio'));</tt> -- During the generation of this URL,
    * default values will be used for the first and
    * last components, and the action shall change. The generated URL will be, "people/hh/david/bio".
    * * <tt>$this->urlFor(array('first'=>'davids-little-brother'));</tt> This
    * generates the URL 'people/hh/davids-little-brother' -- note
    *   that this URL leaves out the assumed action of 'bio'.
    *
    * However, you might ask why the action from the current Request, 'contacts', isn't
    * carried over into the new URL. The answer has to do with the order in which
    * the parameters appear in the generated path. In a nutshell, since the
    * value that appears in the slot for <tt>first</tt> is not equal to default value
    * for <tt>first</tt> we stop using defaults. On it's own, this rule can account
    * for much of the typical PhpOnRails Framework URL behavior.
    *
    * Although a convienence, defaults can occasionaly get in your way. In some cases
    * a default persists longer than desired.
    * The default may be cleared by adding <tt>'name' => null</tt> to <tt>$this->urlFor</tt>'s options.
    * This is often required when writing form helpers, since the defaults in play
    * may vary greatly depending upon where the helper is used from. The following line
    * will redirect to PostController's default action, regardless of the page it is
    * displayed on:
    *
    *   $this->urlFor(array('controller' => 'posts', 'action' => null));
    *
    * If you explicitly want to create a URL that's almost the same as the current URL, you can do so using the
    * overwrite_params options. Say for your posts you have different views for showing and printing them.
    * Then, in the show view, you get the URL for the print view like this
    *
    *   $this->urlFor(array('overwrite_params' => array('action' => 'print')));
    *
    * This takes the current URL as is and only exchanges the action. In contrast,
    * <tt>$this->urlFor(array('action'=>'print'));</tt>
    * would have slashed-off the path components after the changed action.
    */
    public function urlFor($options = array()) {
        return $this->getUrlWriter()->urlFor($this->rewriteOptions($options));
    }

    private $url_writer;

    /**
    * @return AkUrlWriter
    */
    public function getUrlWriter() {
        if ($this->url_writer) return $this->url_writer;
        return $this->url_writer = new AkUrlWriter($this->Request);
    }

    /**
    * This methods are required for retrieving available controllers for URL Routing
    */
    public function rewriteOptions($options) {
        $defaults = $this->defaultUrlOptions($options);
        if(!empty($this->module_name)){
            $defaults['module'] = $this->getModuleName();
        }
        if(!empty($this->Request->lang)&&$this->Request->lang!='cn'){ //will add to brower url
            $defaults['lang']=$this->Request->lang;
        }
       /* if(!empty($this->controller_name)){
            $defaults['controller'] = $this->controller_name;
        }*/

        if(!empty($this->_action_name)){
            $defaults['action']=$this->_action_name;
            unset($options['ak']);
            unset($defaults['ak']);
        }
        $options = !empty($defaults) ? array_merge($defaults, $options) : $options;
        return $options;
    }

    public function addToUrl($options = array(), $options_to_exclude = array()) {
        $options_to_exclude = array_merge(array('ak','lang',SESSION_NAME,'SESSID','PHPSESSID'), $options_to_exclude);
        $options = array_merge(array('action'=>$this->Request->getAction()),$this->params ,$options);
        foreach ($options_to_exclude as $option_to_exclude){
            unset($options[$option_to_exclude]);
        }
        return $this->urlFor($options);
    }

    public function getActionName() {
        return $this->Request->getAction();
    }

    public function hasPerformed() {
        return !empty($this->performed_render) || !empty($this->performed_redirect);
    }

    public function _doubleRenderError($message = null) {
        $Exception = new ControllerException(!empty($message) ? $message : Ak::t("Render and/or redirect were called multiple times in this action. Please note that you may only call render OR redirect, and only once per action. Also note that neither redirect nor render terminate execution of the action, so if you want to exit an action after redirecting, you need to do something like \"redirectTo(...); return;\". Finally, note that to cause a before filter to halt execution of the rest of the filter chain, the filter must return false, explicitly, so \"render(...); return; false\"."));
        $Exception->status = 500;
        throw $Exception;
    }

    public function _getRequestOrigin() {
        return $this->Request->remote_ip.' at '.Ak::getDate();
    }

    public function _getCompleteRequestUri() {
        return $this->Request->protocol . $this->Request->host . $this->Request->request_uri;
    }

    public function _closeSession() {
        !empty($this->session) ? session_write_close() : null;
    }


    public function _hasTemplate($template_name = null) {
        return file_exists(empty($template_name) ? $this->getDefaultTemplateName() : $template_name);
    }

    public function _templateIsPublic($template_name = null) {
        $template_name = empty($template_name) ? $this->getDefaultTemplateName() : $template_name;
        return $this->Template->fileIsPublic($template_name);
    }

    public function _isTemplateExemptFromLayout($template_name = null) {
        $template_name = empty($template_name) ? $this->getDefaultTemplateName() : $template_name;
        return $this->Template->javascriptTemplateExists($template_name);
    }

    public function _assertExistanceOfTemplateFile($template_name) {
        if($this->Template->delegateTemplateExists($template_name) === false){
            if(!empty($this->_ignore_missing_templates) && $this->_ignore_missing_templates === true){
                return true;
            }
            $template_name = $template_name.'.tpl';
            $template_type = strstr($template_name,'layouts') ? 'layout' : 'template';

            $error_message = Ak::t('Missing %template_type %controller_name::%template_name',array('%template_type'=>$template_type, '%template_name'=>$template_name,'%controller_name'=>$this->getControllerName()));
            throw new MissingTemplateException($error_message);
        }
        return true;
    }

    protected function respondTo() {
        return $this->Request->getFormat();
    }

    public function getDefaultTemplateName($default_action_name = null) {
        $template_name = empty($default_action_name) ? (empty($this->_default_template_name) ? $this->_action_name : $this->_default_template_name) : $default_action_name;
        return $template_name.'.'.$this->respondTo();
    }

    public function setDefaultTemplateName($template_name) {
        $this->_default_template_name = $template_name;
    }


    public function toString() {
        return $this->Request->getProtocol().$this->Request->getHostWithPort().
        $this->Request->getPath().@$this->parameters['controller'].
        @$this->parameters['action'].@$this->parameters['inspect'];
    }

    /**
      * Returns a query string with escaped keys and values from the passed array. If the passed
      * array contains an 'id' it'll
      * be added as a path element instead of a regular parameter pair.
      */
    public function buildQueryString($array, $only_keys = null) {
        $array = !empty($only_keys) ? array_keys($array) : $array;
        return Ak::toUrl($array);
    }




    /**
                            Layouts
    ====================================================================
    *
    * Layouts reverse the common pattern of including shared headers and footers in many templates
    * to isolate changes in repeated setups. The inclusion pattern has pages that look like this:
    *
    *   <?php echo  $controller->render('shared/header') ?>
    *   Hello World
    *   <?php echo  $controller->render('shared/footer') ?>
    *
    * This approach is a decent way of keeping common structures isolated from the
    * changing content, but it's verbose and if( you ever want to change the structure
    * of these two includes, you'll have to change all the templates.
    *
    * With layouts, you can flip it around and have the common structure know where
    * to insert changing content. This means that the header and footer are only
    * mentioned in one place, like this:
    *
    *   <!-- The header part of this layout -->
    *   <?php echo  $content_for_layout ?>
    *   <!-- The footer part of this layout -->
    *
    * And then you have content pages that look like this:
    *
    *    hello world
    *
    * Not a word about common structures. At rendering time, the content page is
    * computed and then inserted in the layout,
    * like this:
    *
    *   <!-- The header part of this layout -->
    *   hello world
    *   <!-- The footer part of this layout -->
    *
    * == Accessing shared variables
    *
    * Layouts have access to variables specified in the content pages and vice versa.
    * This allows you to have layouts with references that won't materialize before
    * rendering time:
    *
    *   <h1><?php echo  $page_title ?></h1>
    *   <?php echo  $content_for_layout ?>
    *
    * ...and content pages that fulfill these references _at_ rendering time:
    *
    *    <?php $page_title = 'Welcome'; ?>
    *    Off-world colonies offers you a chance to start a new life
    *
    * The result after rendering is:
    *
    *   <h1>Welcome</h1>
    *   Off-world colonies offers you a chance to start a new life
    *
    * == Automatic layout assignment
    *
    * If there is a template in <tt>app/views/layouts/</tt> with the same name as
    * the current controller then it will be automatically
    * set as that controller's layout unless explicitly told otherwise. Say you have
    * a WeblogController, for example. If a template named <tt>app/views/layouts/weblog.tpl</tt>
    * exists then it will be automatically set as the layout for your WeblogController.
    * You can create a layout with the name <tt>application.tpl</tt>
    * and this will be set as the default controller if there is no layout with
    * the same name as the current controller and there is no layout explicitly
    * assigned on the +layout+ attribute. Setting a layout explicitly will always
    * override the automatic behaviour
    * for the controller where the layout is set. Explicitly setting the layout
    * in a parent class, though, will not override the
    * child class's layout assignement if the child class has a layout with the same name.
    *
    * == Inheritance for layouts
    *
    * Layouts are shared downwards in the inheritance hierarchy, but not upwards. Examples:
    *
    *   class BankController extends AkActionController
    *   {
    *     public $layout = 'bank_standard';
    *   }
    *
    *   class InformationController extends BankController
    *   {
    *   }
    *
    *   class VaultController extends BankController
    *   {
    *      public $layout  = 'access_level_layout';
    *   }
    *
    *   class EmployeeController extends BankController
    *   {
    *       public $layout = null;
    *   }
    *
    * The InformationController uses 'bank_standard' inherited from the BankController, the VaultController
    * and picks the layout 'access_level_layout', and the EmployeeController doesn't want to use a layout at all.
    *
    * == Types of layouts
    *
    * Layouts are basically just regular templates, but the name of this template needs not be specified statically. Sometimes
    * you want to alternate layouts depending on runtime information, such as whether someone is logged in or not. This can
    * be done either by an inline method.
    *
    * The method reference is the preferred approach to variable layouts and is used like this:
    *
    *   class WeblogController extends AkActionController
    *   {
    *       public function __construct()
    *       {
    *           $this->setLayout(array($this, '_writersAndReaders'));
    *       }
    *
    *       public function index()
    *       {
    *           // fetching posts
    *       }
    *
    *       public function _writersAndReaders()
    *       {
    *           return is_logged_in() ? 'writer_layout' : 'reader_layout';
    *       }
    *   }
    *
    * Now when a new request for the index action is processed, the layout will vary depending on whether the person accessing
    * is logged in or not.
    *
    * The most common way of specifying a layout is still just as a plain template name:
    *
    *   class WeblogController extends AkActionController
    *   {
    *      public $layout = 'weblog_standard';
    *   }
    *
    * If no directory is specified for the template name, the template will by default by looked for in +app/views/layouts/+.
    *
    * == Conditional layouts
    *
    * If you have a layout that by default is applied to all the actions of a controller, you still have the option of rendering
    * a given action or set of actions without a layout, or restricting a layout to only a single action or a set of actions. The
    * <tt>only</tt> and <tt>except</tt> options can be passed to the layout call. For example:
    *
    *   class WeblogController extends AkActionController
    *   {
    *       public function __construct()
    *       {
    *           $this->setLayout('weblog_standard', array('except' => 'rss'));
    *       }
    *
    *     // ...
    *
    *   }
    *
    * This will assign 'weblog_standard' as the WeblogController's layout  except for the +rss+ action, which will not wrap a layout
    * around the rendered view.
    *
    * Both the <tt>only</tt> and <tt>except</tt> condition can accept an arbitrary number of method names, so
    * <tt>'except' => array('rss', 'text_only')</tt> is valid, as is <tt>'except' => 'rss'</tt>.
    *
    * == Using a different layout in the action render call
    *
    * If most of your actions use the same layout, it makes perfect sense to define a controller-wide layout as described above.
    * Some times you'll have exceptions, though, where one action wants to use a different layout than the rest of the controller.
    * This is possible using the <tt>render</tt> method. It's just a bit more manual work as you'll have to supply fully
    * qualified template and layout names as this example shows:
    *
    *   class WeblogController extends AkActionController
    *   {
    *       public function help()
    *       {
    *           $this->render(array('action'=>'help/index','layout'=>'help'));
    *       }
    *   }
    */

    /**
    * If a layout is specified, all actions rendered through render and render_action will have their result assigned
    * to <tt>$this->content_for_layout</tt>, which can then be used by the layout to insert their contents with
    * <tt><?php echo  $$this->content_for_layout ?></tt>. This layout can itself depend on instance variables assigned during action
    * performance and have access to them as any normal template would.
    */
    public function setLayout($template_name, $conditions = array()) {
        $this->_addLayoutConditions($conditions);
        $this->layout = $template_name;
    }

    public function getLayoutConditions() {
        return empty($this->_layout_conditions) ? array() : $this->_layout_conditions;
    }

    public function _addLayoutConditions($conditions) {
        $this->_layout_conditions = $conditions;
    }



    /**
    * Returns the name of the active layout. If the layout was specified as a method reference, this method
    * is called and the return value is used. Likewise if( the layout was specified as an inline method (through a method
    * object). If the layout was defined without a directory, layouts is assumed. So <tt>setLayout('weblog/standard')</tt> will return
    * weblog/standard, but <tt>setLayout('standard')</tt> will return layouts/standard.
    */
    public function getActiveLayout($passed_layout = null) {
        if(empty($passed_layout)){
            $layout = !isset($this->layout) ? AkInflector::underscore($this->getControllerName()) : $this->layout;
        }else{
            $layout = $passed_layout;
        }
        if(is_array($layout) &&  is_object($layout[0]) && method_exists($layout[0], $layout[1])){
            $active_layout = $layout[0]->{$layout[1]}();
        }elseif(method_exists($this,$layout) &&  strtolower(get_class($this)) !== strtolower($layout)){
            $active_layout = $this->$layout();
        }else{
            $active_layout = $layout;
        }

        if(!empty($active_layout)){
            if(file_exists($active_layout))
                return $active_layout;
            else
                return strstr($active_layout,'/') ? str_replace('/',DS,$active_layout) : 'layouts'.DS.$active_layout;
        }
        return false;
    }


    public function renderWithALayout($options = null, $status = null, $layout = null) {
        $template_with_options = !empty($options)  && is_array($options);

        if($this->_canApplyLayout($template_with_options, $options) && ($layout = $this->_pickLayout($template_with_options, $options, $layout))){

            $options = $template_with_options? array_merge((array)$options,array('layout'=>false)) : $options;

            $this->content_for_layout = $this->render($options, $status);

            if($template_with_options){
                $status = empty($options['status']) ? $status : $options['status'];
            }

            $this->eraseRenderResults();
            $this->_addVariablesToAssigns();

            return $this->renderText($this->Template->renderFile($layout, true, $this->_assigns), $status);
        }else{
            return $this->render($options, $status);
        }
    }

    public function _canApplyLayout($template_with_options, $options) {
        return !empty($template_with_options) ?  $this->_isCandidateForLayout($options) : !$this->_isTemplateExemptFromLayout();
    }

    public function _isCandidateForLayout($options) {
        return !empty($options['layout']) ||
        (empty($options['text']) && empty($options['file']) && empty($options['inline']) && empty($options['partial']) && empty($options['nothing'])) &&
        !$this->_isTemplateExemptFromLayout($this->_getDefaultTemplateName(empty($options['action']) ? $options['template'] : $options['action']));
    }

    public function _pickLayout($template_with_options, $options, $layout = null) {
        if(!empty($template_with_options)){
            $layout = empty($options['layout']) ? ($this->_doesActionHasLayout() ? $this->getActiveLayout(): false) : $this->getActiveLayout($options['layout']);
        }elseif(empty($layout) || $layout === true){
            $layout = $this->_doesActionHasLayout() ? $this->getActiveLayout() : false;
        }

        if(!empty($layout)){
            if(!file_exists($layout)){
                $layout = strstr($layout,'/') || strstr($layout,DS) ? $layout : 'layouts'.DS.$layout;
                $layout = preg_replace('/\.tpl$/', '', $layout);

                $layout = preg_replace('/\.tpl$/', '', $layout);

                $layout = empty($this->_module_path) || !empty($this->layout)
                ? AkConfig::getDir('views').DS.$layout.'.tpl'
                : AkConfig::getDir('views').DS.'layouts'.DS.trim($this->_module_path, DS).'.tpl';

            }
            if (file_exists($layout)) {
                return $layout;
            }
            $layout = null;
        }
        if(empty($layout) && $layout !== false && defined('DEFAULT_LAYOUT')){
            $layout = AkConfig::getDir('views').DS.'layouts'.DS.DEFAULT_LAYOUT.'.tpl';
        }
        return file_exists($layout) ? $layout : false;
    }

    public function _doesActionHasLayout() {
        $conditions = $this->getLayoutConditions();

        $action_name = $this->Request->getAction();
        if(!empty($conditions['only']) && ((is_array($conditions['only']) && in_array($action_name,$conditions['only'])) ||
        (is_string($conditions['only']) && $action_name == $conditions['only']))){
            return true;
        }elseif (!empty($conditions['only'])){
            return false;
        }
        if(!empty($conditions['except']) && ((is_array($conditions['except']) && in_array($action_name,$conditions['except'])) ||
        (is_string($conditions['except']) && $action_name == $conditions['except']))){
            return false;
        }

        return true;
    }





    /**
                    Flash communication between actions
    ====================================================================
    *
    * The flash provides a way to pass temporary objects between actions. Anything you place in the flash will be exposed
    * to the very next action and then cleared out. This is a great way of doing notices and alerts, such as a create action
    * that sets <tt>flash['notice] = 'Successfully created'</tt> before redirecting to a display action that can then expose
    * the flash to its template. Actually, that exposure is automatically done. Example:
    *
    *   class WeblogController extends ActionController
    *   {
    *       public function create()
    *       {
    *           // save post
    *           $this->flash['notice] = 'Successfully created post';
    *           $this->redirectTo(array('action'=>'display','params' => array('id' =>$Post->id)));
    *       }
    *
    *       public function display()
    *       {
    *           // doesn't need to assign the flash notice to the template, that's done automatically
    *       }
    *   }
    *
    *   display.tpl
    *     <?php if($flash['notice']) : ?><div class='notice'><?php echo $flash['notice'] ?></div><?php endif; ?>
    *
    * This example just places a string in the flash, but you can put any object in there. And of course, you can put as many
    * as you like at a time too. Just remember: They'll be gone by the time the next action has been performed.
    *
    * ==flash_now
    *
    * Sets a flash that will not be available to the next action, only to the current.
    *
    *     $this->flash_now['message] = 'Hello current action';
    *
    * This method enables you to use the flash as a central messaging system in your app.
    * When you need to pass an object to the next action, you use the standard flash assign (<tt>[]=</tt>).
    * When you need to pass an object to the current action, you use <tt>now</tt>, and your object will
    * vanish when the current action is done.
    *
    * Entries set via <tt>flash_now</tt> are accessed the same way as standard entries: <tt>flash['my-key']</tt>.
    */
    public $flash = array();
    public $flash_now = array();
    public $flash_options = array();
    public $_flash_handled = false;

    public function _handleFlashAttribute(&$new_attributes = array()) {
        
        $flash = Ak::deleteAndGetValue($new_attributes, array('notice','error','message'));
        if(!empty($flash)){
            foreach ($flash as $k => $v){
                $this->flash[$k] = $v;
            }
        }
        
        if(!$this->_flash_handled){
            $this->_flash_handled = true;
            $next_flash = empty($this->flash) ? false : $this->flash;
            $this->flash = array();
            if(isset($_SESSION['__flash'])){
                $this->flash = $_SESSION['__flash'];
            }
            $_SESSION['__flash'] = $next_flash;
            if(!empty($this->flash_now)){
                $this->flash = array_merge((array)$this->flash,(array)$this->flash_now);
            }
            $this->_handleFlashOptions();
        }
        // remove empty values
        $_SESSION = array_diff($_SESSION, array(''));
    }

    public function _handleFlashOptions() {
        $next_flash_options = empty($this->flash_options) ? false : $this->flash_options;
        $this->flash_options = array();
        if(isset($_SESSION['__flash_options'])){
            $this->flash_options = $_SESSION['__flash_options'];
        }
        $_SESSION['__flash_options'] = $next_flash_options;
        if(!empty($this->flash_now_options)){
            $this->flash_options = array_merge((array)$this->flash_options,(array)$this->flash_now_options);
        }
    }


    public function _mergeFlashOnFlashNow() {
        $this->flash_now = array_merge($this->flash_now,$this->flash);
    }


    /**
                    Pagination for Active Record collections
    ====================================================================
    *
    * The Pagination module aids in the process of paging large collections of
    * Active Record objects. It offers macro-style automatic fetching of your
    * model for multiple views, or explicit fetching for single actions. And if
    * the magic isn't flexible enough for your needs, you can create your own
    * paginators with a minimal amount of code.
    *
    * The Pagination module can handle as much or as little as you wish. In the
    * controller, have it automatically query your model for pagination; or,
    * if you prefer, create Paginator objects yourself
    *
    * Pagination is included automatically for all controllers.
    *
    * For help rendering pagination links, see
    * Helpers/PaginationHelper.
    *
    * ==== Automatic pagination for every action in a controller
    *
    *   class PersonController extends ApplicationController
    *   {
    *       public $model = 'person';
    *       public $paginate = array('people'=>array('order' => 'last_name, first_name',
    *              'per_page' => 20));
    *   }
    *
    * Each action in this controller now has access to a <tt>$this->people</tt>
    * instance variable, which is an ordered collection of model objects for the
    * current page (at most 20, sorted by last name and first name), and a
    * <tt>$this->person_pages</tt> Paginator instance. The current page is determined
    * by the <tt>$params['page']</tt> variable.
    *
    * ==== Pagination for a single action
    *
    *   function show_all()
    *   {
    *       list($this->person_pages, $this->people) =
    *       $this->paginate('people', array('order' => 'last_name, first_name'));
    *   }
    *
    * Like the previous example, but explicitly creates <tt>$this->person_pages</tt>
    * and <tt>$this->people</tt> for a single action, and uses the default of 10 items
    * per page.
    *
    * ==== Custom/"classic" pagination
    *
    *   function list()
    *   {
    *       $this->person_pages = new AkPaginator($this, $Person->count(), 10, $params['page']);
    *       $this->people = $this->Person->find('all', array(
    *                       'order'=> 'last_name, first_name',
    *                       'limit' =>  $this->person_pages->items_per_page,
    *                       'offset' =>  $this->person_pages->getOffset()));
    *   }
    *
    * Explicitly creates the paginator from the previous example and uses
    * AkPaginator::toSql to retrieve <tt>$this->people</tt> from the model.
    */
    // An array holding options for controllers using macro-style pagination
    public $_pagination_options = array(
    'class_name' => null,
    'singular_name' => null,
    'per_page' => 10,
    'conditions' => null,
    'order_by' => null,
    'order' => null,
    'join' => null,
    'joins' => null,
    'include' => null,
    'select' => null,
    'parameter' => 'page'
    );

    // The default options for pagination
    public $_pagination_default_options = array(
    'class_name' => null,
    'singular_name' => null,
    'per_page' => 10,
    'conditions' => null,
    'order_by' => null,
    'order' => null,
    'join' => null,
    'joins' => null,
    'include' => null,
    'select' => null,
    'parameter' => 'page'
    );

    public $_pagination_actions = array();

    public function _paginationValidateOptions($collection_id, $options = array(), $in_action) {
        $this->_pagination_options = array_merge($this->_pagination_default_options, $this->_pagination_options, $options);
        $valid_options = array_keys($this->_pagination_default_options);

        $valid_options = !in_array($in_action, $valid_options) ? array_merge($valid_options, $this->_pagination_actions) : $valid_options;

        $unknown_option_keys = array_diff(array_keys($this->_pagination_options) , $valid_options);

        if(!empty($unknown_option_keys)){
            throw new ControllerException(Ak::t('Unknown options for pagination: %unknown_option',array('%unknown_option'=>join(', ',$unknown_option_keys))));
        }

        $this->_pagination_options['singular_name'] = !empty($this->_pagination_options['singular_name']) ? $this->_pagination_options['singular_name'] : AkInflector::singularize($collection_id);
        $this->_pagination_options['class_name'] = !empty($this->_pagination_options['class_name']) ? $this->_pagination_options['class_name'] : AkInflector::camelize($this->_pagination_options['singular_name']);
    }

    /**
    * Returns a paginator and a collection of Active Record model instances
    * for the paginator's current page. This is designed to be used in a
    * single action.
    *
    * +options+ are:
    * <tt>singular_name</tt>:: the singular name to use, if it can't be inferred by
    *                        singularizing the collection name
    * <tt>class_name</tt>:: the class name to use, if it can't be inferred by
    *                        camelizing the singular name
    * <tt>per_page</tt>::   the maximum number of items to include in a
    *                        single page. Defaults to 10
    * <tt>conditions</tt>:: optional conditions passed to Model::find('all', $this->params); and
    *                        Model::count()
    * <tt>order</tt>::      optional order parameter passed to Model::find('all', $this->params);
    * <tt>order_by</tt>::   (deprecated, used :order) optional order parameter passed to Model::find('all', $this->params)
    * <tt>joins</tt>::      optional joins parameter passed to Model::find('all', $this->params)
    *                        and Model::count()
    * <tt>join</tt>::       (deprecated, used :joins or :include) optional join parameter passed to Model::find('all', $this->params)
    *                        and Model::count()
    * <tt>include</tt>::    optional eager loading parameter passed to Model::find('all', $this->params)
    *                        and Model::count()
    *
    * Creates a +before_filter+ which automatically paginates an Active
    * Record model for all actions in a controller (or certain actions if
    * specified with the <tt>actions</tt> option).
    *
    * +options+ are the same as AkPaginationHelper::paginate, with the addition
    * of:
    * <tt>actions</tt>:: an array of actions for which the pagination is
    *                     active. Defaults to +null+ (i.e., every action)
    */
    public function paginate($collection_id, $options = array()) {
        $this->_paginationValidateOptions($collection_id, $options, true);
        $this->_paginationLoadPaginatorAndCollection($collection_id, $this->_pagination_options);
        $this->beforeFilter('_paginationCreateAndRetrieveCollections');
    }

    public function _paginationCreateAndRetrieveCollections() {
        foreach($this->_pagination_options[$this->class]  as $collection_id=>$options){
            if(!empty($options['actions']) && in_array($options['actions'], $this->getActionName())){
                continue;
            }

            list($paginator, $collection) = $this->_paginationLoadPaginatorAndCollection($collection_id, $this->_pagination_options);

            $this->{$options['singular_name'].'_pages'} = $paginator;
            $this->$collection_id = $collection;
        }
    }

    /**
    * Returns the total number of items in the collection to be paginated for
    * the +model+ and given +conditions+. Override this method to implement a
    * custom counter.
    */
    public function _paginationCountCollection(&$model, $conditions, $joins) {
        return $model->count($conditions, $joins);
    }

    /**
    * Returns a collection of items for the given +$model+ and +$options['conditions']+,
    * ordered by +$options['order']+, for the current page in the given +$paginator+.
    * Override this method to implement a custom finder.
    */
    public function _paginationFindCollection(&$model, $options, &$paginator) {
        return $model->find('all', array(
        'conditions' => $this->_pagination_options['conditions'],
        'order' => !empty($options['order_by']) ? $options['order_by'] : $options['order'],
        'joins' => !empty($options['join']) ? $options['join'] : $options['joins'],
        'include' => $this->_pagination_options['include'],
        'select' => $this->_pagination_options['select'],
        'limit' => $this->_pagination_options['per_page'],
        'offset' => $paginator->getOffset()));
    }

    /**
     * @todo Fix this function
     */
    public function _paginationLoadPaginatorAndCollection($collection_id, $options) {
        $page = $this->params[$options['parameter']];
        $count = $this->_paginationCountCollection($this->$collection_id, $options['conditions'],
        empty($options['join']) ? $options['join'] : $options['joins']);

        $paginator = new AkPaginator($this, $count, $options['per_page'], $page);
        $collection = $this->_paginationFindCollection($options['class_name'], $options, $paginator);

        return array($paginator, $collection);
    }

    /**
                        Protocol conformance
    ====================================================================
    */

    /**
     * Specifies that the named actions requires an SSL connection to be performed (which is enforced by ensure_proper_protocol).
     */
    public function setSslRequiredActions($actions) {
        $this->_ssl_required_actions = empty($this->_ssl_required_actions) ?
        (is_string($actions) ? Ak::stringToArray($actions) : $actions) :
        array_merge($this->_ssl_required_actions, (is_string($actions) ? Ak::stringToArray($actions) : $actions));
    }

    public function setSslAllowedActions($actions) {
        $this->_ssl_allowed_actions = empty($this->_ssl_allowed_actions) ?
        (is_string($actions) ? Ak::stringToArray($actions) : $actions) :
        array_merge($this->_ssl_allowed_actions, (is_string($actions) ? Ak::stringToArray($actions) : $actions));
    }

    /**
     * Returns true if the current action is supposed to run as SSL
     */
    public function isSslRequired() {
        return !empty($this->_ssl_required_actions) && is_array($this->_ssl_required_actions) && isset($this->_action_name) ?
        in_array($this->_action_name, $this->_ssl_required_actions) : false;
    }

    public function isSslAllowed() {
        return (!empty($this->ssl_for_all_actions) && empty($this->_ssl_allowed_actions)) ||
        (!empty($this->_ssl_allowed_actions) && is_array($this->_ssl_allowed_actions) && isset($this->_action_name) ?
        in_array($this->_action_name, $this->_ssl_allowed_actions) : false);
    }

    public function _ensureProperProtocol() {
        if($this->isSslAllowed() && $this->Request->isSsl()){
            return true;
        }
        if ($this->isSslRequired() && !$this->Request->isSsl() && $this->isSslAllowed()){
            $this->redirectTo(substr_replace(CURRENT_URL,'s:',4,1));
            return false;
        }elseif($this->Request->isSsl() && (!$this->isSslRequired() || !$this->isSslAllowed())){
            $this->redirectTo(substr_replace(CURRENT_URL,'',4,1));
            return false;
        }
        return true;
    }

    /**
                            Account Location
    ====================================================================
    *
    * Account location is a set of methods that supports the account-key-as-subdomain
    * way of identifying the current scope. These methods allow you to easily produce URLs that
    * match this style and to get the current account key from the subdomain.
    *
    * The methods are: getAccountUrl, getAccountHost, and getAccountDomain.
    *
    * Example:
    *
    * include_once('AkAccountLocation.php');
    *
    * class ApplicationController extends AkActionController
    * {
    *   public function __construct(){
    *       $this->beforeFilter('_findAccount');
    *   }
    *
    *   public function _findAccount(){
    *       $this->Account = Ak::get('Account')->findFirstBy('host', $this->getAccountSubdomain());
    *   }
    * }
    *
    *   class AccountController extends ApplicationController
    *   {
    *       public function new_account()
    *       {
    *           $this->new_account = Account::create($this->params['new_account']);
    *           $this->redirectTo(array('host' => $this->accountHost($this->new_account->username), 'controller' => 'weblog'));
    *       }
    *
    *       public function authenticate()
    *       {
    *           $this->session[$this->account_domain] = 'authenticated';
    *           $this->redirectTo(array('controller => 'weblog'));
    *       }
    *
    *       public function _isAuthenticated()
    *       {
    *           return !empty($this->session['account_domain']) ? $this->session['account_domain'] == 'authenticated' : false;
    *       }
    *   }
    *
    *   // The view:
    *   Your domain: {account_url?}
    *
    *   By default, all the methods will query for $this->account->username as the account key, but you can
    *   specialize that by overwriting defaultAccountSubdomain. You can of course also pass it in
    *   as the first argument to all the methods.
    */
    public function defaultAccountSubdomain() {
        if(!empty($this->account)){
            return $this->account->respondsTo('username');
        }
        return '';
    }

    public function accountUrl($account_subdomain = null, $use_ssl = null) {
        $account_subdomain = empty($account_subdomain) ? 'default_account_subdomain' : $account_subdomain;
        $use_ssl = empty($use_ssl) ? $use_ssl : $this->Request->isSsl();
        return ($use_ssl ? 'https://' : 'http://') . $this->accountHost($account_subdomain);
    }

    public function accountHost($account_subdomain = null) {
        $account_subdomain = empty($account_subdomain) ? 'default_account_subdomain' : $account_subdomain;
        $account_host = '';
        $account_host .= $account_subdomain . '.';
        $account_host .= $this->accountDomain();
        return $account_host;
    }

    public function accountDomain() {
        $account_domain = '';
        if(count($this->Request->getSubdomains()) > 1){
            $account_domain .= join('.',$this->Request->getSubdomains()) . '.';
        }
        $account_domain .= $this->Request->getDomain() . $this->Request->getPortString();
        return $account_domain;
    }

    public function getAccountSubdomain() {
        return Ak::first($this->Request->getSubdomains());
    }


    /**
                            Data streaming
    ====================================================================
    Methods for sending files and streams to the browser instead of rendering.
    */

    public $default_send_file_options = array(
    'type'          => 'application/octet-stream',
    'disposition'   => 'attachment',
    'stream'        => true,
    'buffer_size'   => 4096,
    'x_sendfile'    => false
    );

    /**
    * Sends the file by streaming it 4096 bytes at a time. This way the
    * whole file doesn't need to be read into memory at once.  This makes
    * it feasible to send even large files.
    *
    * Be careful to sanitize the path parameter if it coming from a web
    * page.  sendFile($params['path']) allows a malicious user to
    * download any file on your server.
    *
    * Options:
    * * <tt>filename</tt> - suggests a filename for the browser to use.
    *   Defaults to realpath($path).
    * * <tt>type</tt> - specifies an HTTP content type.
    *   Defaults to 'application/octet-stream'.
    * * <tt>disposition</tt> - specifies whether the file will be shown inline or downloaded.
    *   Valid values are 'inline' and 'attachment' (default).
    * * <tt>stream</tt> - whether to send the file to the user agent as it is read (true)
    *   or to read the entire file before sending (false). Defaults to true.
    * * <tt>buffer_size</tt> - specifies size (in bytes) of the buffer used to stream the file.
    *   Defaults to 4096.
    * <tt>:x_sendfile</tt> - uses X-Sendfile to send the file when set to +true+. This is currently
        only available with Lighttpd/Apache2 and specific modules installed and activated. Since this
    *   uses the web server to send the file, this may lower memory consumption on your server and
    *   it will not block your application for further requests.
    *   See http://blog.lighttpd.net/articles/2006/07/02/x-sendfile and
    *   http://tn123.ath.cx/mod_xsendfile/ for details. Defaults to +false+.
    *
    * The default Content-Type and Content-Disposition headers are
    * set to download arbitrary binary files in as many browsers as
    * possible.  IE versions 4, 5, 5.5, and 6 are all known to have
    * a variety of quirks (especially when downloading over SSL).
    *
    * Simple download:
    *   sendFile('/path/to.zip');
    *
    * Show a JPEG in browser:
    *   sendFile('/path/to.jpeg', array('type' => 'image/jpeg', 'disposition' => 'inline'));
    *
    * Read about the other Content-* HTTP headers if you'd like to
    * provide the user with more information (such as Content-Description).
    * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11
    *
    * Also be aware that the document may be cached by proxies and browsers.
    * The Pragma and Cache-Control headers declare how the file may be cached
    * by intermediaries.  They default to require clients to validate with
    * the server before releasing cached responses.  See
    * http://www.mnot.net/cache_docs/ for an overview of web caching and
    * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9
    * for the Cache-Control header spec.
    */
    public function sendFile($path, $options = array()) {
        $path = realpath($path);
        if(!file_exists($path)){
            $Exception = new ControllerException(Ak::t('Cannot read file %path',array('%path'=>$path)));
            $Exception->status = 500;
            throw $Exception;
        }
        $this->performed_render = false;
        
        if(!empty($options['x_sendfile'])){
            $this->_log("Sending X-Sendfile header $path");
            $this->Response->addHeader(array('X-Sendfile'  => $path));
            $this->renderNothing(empty($options['status']) ? 200 : $options['status']);
            return;
        }
        
        $options['length'] = empty($options['length']) ? filesize($path) : $options['length'];
        $options['filename'] = empty($options['filename']) ? basename($path) : $options['filename'];
        $options['type'] = empty($options['type']) ? Ak::mime_content_type($path) : $options['type'];

        $this->_sendFileHeaders($options);

        if(!empty($options['stream'])){
            $this->render(array('text'=> new AkStream($path,$options['buffer_size'])));
        }else{
            $this->render(array('text'=> AkFileSystem::file_get_contents($path)));
        }
    }

    /**
    * Send binary data to the user as a file download.  May set content type, apparent file name,
    * and specify whether to show data inline or download as an attachment.
    *
    * Options:
    * * <tt>filename</tt> - Suggests a filename for the browser to use.
    * * <tt>type</tt> - specifies an HTTP content type.
    *   Defaults to 'application/octet-stream'.
    * * <tt>disposition</tt> - specifies whether the file will be shown inline or downloaded.
    *   Valid values are 'inline' and 'attachment' (default).
    *
    * Generic data download:
    *   sendData($buffer)
    *
    * Download a dynamically-generated tarball:
    *   sendData(Ak::compress('dir','tgz'), array('filename' => 'dir.tgz'));
    *
    * Display an image Active Record in the browser:
    *   sendData($image_data, array('type' =>Ak::mime_content_type('image_name.png'), 'disposition' => 'inline'));
    *
    * See +sendFile+ for more information on HTTP Content-* headers and caching.
    */
    public function sendData($data, $options = array()) {
        $options['length'] = empty($options['length']) ? Ak::size($data) : $options['length'];
        $this->_sendFileHeaders($options);
        $this->performed_render = false;
        $this->renderText($data);
    }

    /**
     * Creates a file for streaming from a file.
     * This way you might free memory usage is file is too large
     */
    public function sendDataAsStream($data, $options) {
        $temp_file_name = tempnam(AkConfig::getDir('tmp'), Ak::randomString());
        $fp = fopen($temp_file_name, 'w');
        fwrite($fp, $data);
        fclose($fp);
        $this->sendFile($temp_file_name, $options);
    }


    public function _sendFileHeaders(&$options) {
        $options = array_merge($this->default_send_file_options,$options);
        foreach (array('length', 'type', 'disposition') as $arg){
            if(empty($options[$arg])){
                $Exception = new ControllerException(Ak::t('%arg option required', array('%arg'=>$arg)));
                $Exception->status = 500;
                throw $Exception;
            }
        }
        $disposition = empty($options['disposition']) ? 'attachment' : $options['disposition'];
        $disposition .= !empty($options['filename']) ? '; filename="'.$options['filename'].'"' : '';
        $this->Response->addHeader(array(
        'Content-Length'  => $options['length'],
        'Content-Type'    => trim($options['type']), // fixes a problem with extra '\r' with some browsers
        'Content-Disposition'       => $disposition,
        'Content-Transfer-Encoding' => 'binary'
        ));

    }


    public function redirectToLocale($locale) {
        if($this->Request->__internationalization_support_enabled){
            $lang = isset($this->params['lang']) ? $this->params['lang'] : $locale;

            if($locale != $lang){
                $this->redirectTo(array_merge($this->Request->getUrlParams(),array('lang'=>$locale)));
                return true;
            }
        }
        return false;
    }


    public function api($protocol = 'xml_rpc') {
        $web_services = array_merge(Ak::toArray($this->web_services), Ak::toArray($this->web_service));
        if(!empty($web_services)){
            $web_services = array_unique($web_services);
            $Server = new AkActionWebServiceServer($protocol);
            foreach ($web_services as $web_service){
                $Server->addService($web_service);
            }
            $Server->init();
            $Server->serve();
            exit;
        }else{
            die(Ak::t('There is not any webservice configured at this endpoint'));
        }
    }




    public function _ensureActionExists() {

        if(!method_exists($this, $this->getActionName())){
            throw new UnknownActionException('No action responded to '.$this->getActionName().'. Actions: '.join(', ',$this->getAvailableActions()));
        }elseif($this->_isActionForbidden()){
            throw new ForbiddenActionException('Forbidden action '.$this->getActionName().' called. Available actions are: '.join(', ',$this->getAvailableActions()));
        }
        return true;
    }

    public function getAvailableActions(){
        $actions = array();
        $klass = get_class($this);
        $actions = array_diff(get_class_methods($klass), get_class_methods(__CLASS__));
        foreach ($actions as $k => $action){
            if($action[0] == '_' || AkInflector::underscore($action) != $action){
                unset($actions[$k]);
            }
        }
        return $actions;
    }

    public function _isActionForbidden() {
        $methods = get_class_methods('AkActionController');
        $action = $this->getActionName();
        return empty($action) || in_array($action , $methods) || $action != AkInflector::underscore($action) || $action[0] == '_';
    }
    /**
     * ########################################################################
     * #
     * #               Modules
     * #
     * ########################################################################
     */


    public function _initCacheHandler() {
        // TODOARNO
        $cache_settings = Ak::getSettings('caching', false);
        if ($cache_settings['enabled']) {
            $null = null;
            $this->_CacheHandler = Ak::singleton('AkCacheHandler', $null);
            $this->_CacheHandler->init($this);
        }
    }
    public function getAppliedCacheType() {
        if ($this->cacheConfigured()) {
            return $this->_CacheHandler->getCacheType();
        }
        return null;
    }
    /**
     * ########################################################################
     * #
     * #               START Module: AkActionControllerCaching
     * #
     * ########################################################################
     */
    public function cacheConfigured() {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->cacheConfigured();
    }
    
    public function cachePage($content, $path = null) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->cachePage($content, $path);
    }

    public function getCachedPage($path = null, $lang = null) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->getCachedPage($path, $lang);
    }

    public function expirePage($options, $forced_language = null) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->expirePage($options, $forced_language);
    }
    
    public function fragmentCacheKey($key) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->fragmentCacheKey($key);
    }
    
    public function cacheTplFragmentStart($key, $options = array()) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->cacheTplFragmentStart($key, $options);
    }

    public function cacheTplFragmentEnd($key, $options = array()) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->cacheTplFragmentEnd($key, $options);
    }

    public function writeFragment($key, $content, $options = array()) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->writeFragment($key,$content, $options);
    }

    public function readFragment($key, $options = array()) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->readFragment($key,$options);
    }

    public function expireFragment($key, $options = array()) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->expireFragment($key,$options);
    }
    
    public function expireAction($options = array()) {
        if (!isset($this->_CacheHandler)) return false;
        return $this->_CacheHandler->expireAction($options);
    }

    /**
     * ########################################################################
     * #
     * #               END Module: AkActionControllerCaching
     * #
     * ########################################################################
     */


    // Lazy helper loading

    public function __get($attribute) {
        $matches = array();
        if(preg_match('/^(.+)_helper$/', $attribute, $matches)){
            $this->getHelperLoader()->instantiateHelperAsHandlerAttribute($matches[1], $matches[0]);
            if(isset($this->$attribute)){
                return $this->$attribute;
            }
        }
        if(!isset($this->_dynamic_attributes[$attribute])){
            return parent::__get($attribute);
        }
        return $this->_dynamic_attributes[$attribute];
    }

    public function __set($attribute, $value) {
        $this->_dynamic_attributes[$attribute] = $value;
        $this->$attribute = $value;
    }

    public function &getHelperLoader() {
        if(empty($this->_HelperLoader)){
            $this->_HelperLoader = new AkHelperLoader();
            $this->_HelperLoader->setController($this);
        }
        return $this->_HelperLoader;
    }

    protected function _log($message, $parameters = array(), $type = 'info'){
        if(LOG_EVENTS){
            if(empty($this->_Logger)){
                $this->_Logger = Ak::getLogger();
            }
            $this->_Logger->$type($message, $parameters);
        }
    }
    
    protected function _logRequestParams($log_params){
        if(!empty($this->filter_parameter_logging)){
            array_walk_recursive($log_params, array($this, '_filterRequestParamsForLogging'));
        }
        try{
            $this->_log('Parameters', array_diff(Ak::delete($log_params, $this->skip_parameter_logging), array('')));
        }catch(Exception $p){

        }
    }

    protected function _filterRequestParamsForLogging(&$value, $key) {
        if(in_array($key, $this->filter_parameter_logging)){
            $value = '[FILTERED]';
        }
    }

    protected function __getFailOver($name) {
        $this->$name = Ak::get($name);
        return $this->$name instanceof AkBaseModel;
    }
}

